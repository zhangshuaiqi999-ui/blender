<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Blender 轴心点模式可视化</title>
    <style>
        body {
            background-color: #1e1e1e;
            color: #dcdcdc;
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        h2 { margin-bottom: 10px; color: #fff; }
        .container {
            position: relative;
            background-color: #2b2b2b;
            border: 1px solid #3d3d3d;
            border-radius: 4px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        canvas {
            display: block;
            cursor: crosshair;
        }
        .controls {
            margin-top: 15px;
            display: flex;
            gap: 20px;
            background: #333;
            padding: 15px;
            border-radius: 8px;
            align-items: center;
        }
        .mode-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        label {
            cursor: pointer;
            display: flex;
            align-items: center;
            font-size: 14px;
        }
        input[type="radio"] {
            margin-right: 8px;
            accent-color: #eb7d00;
        }
        .slider-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            width: 200px;
        }
        input[type="range"] {
            width: 100%;
            cursor: pointer;
            accent-color: #4772b3;
        }
        .desc {
            margin-top: 15px;
            font-size: 14px;
            color: #aaa;
            max-width: 600px;
            line-height: 1.5;
            background: #252525;
            padding: 10px;
            border-radius: 4px;
            border-left: 4px solid #eb7d00;
        }
        /* Blender UI Simulation */
        .cursor-icon {
            position: absolute;
            pointer-events: none;
            width: 20px;
            height: 20px;
            border: 1px dashed rgba(255,255,255,0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        .cursor-crosshair {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        .cursor-crosshair::before, .cursor-crosshair::after {
            content: '';
            position: absolute;
            background: #ff4444;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .cursor-crosshair::before { width: 14px; height: 1px; }
        .cursor-crosshair::after { width: 1px; height: 14px; }
        
        strong { color: #eb7d00; }
    </style>
</head>
<body>

    <h2>Blender 曲线缩放模式模拟器</h2>
    
    <div class="container">
        <canvas id="graphCanvas" width="600" height="300"></canvas>
    </div>

    <div class="controls">
        <div class="mode-group">
            <label><input type="radio" name="mode" value="bbox" checked> 1. 包围盒中心 (默认)</label>
            <label><input type="radio" name="mode" value="cursor"> 2. 2D 游标 (定点缩放)</label>
            <label><input type="radio" name="mode" value="individual"> 3. 各自中心 (Individual)</label>
        </div>

        <div class="slider-group">
            <label for="scaleSlider">缩放力度 (Scale): <span id="scaleVal">1.0</span>x</label>
            <input type="range" id="scaleSlider" min="0" max="2.5" step="0.01" value="1.0">
        </div>
    </div>

    <div class="desc" id="description">
        选中了 <strong>包围盒中心</strong>。这是默认模式。<br>
        当你缩放时，所有关键帧会向<strong>整体的几何中心</strong>收缩。就像挤压弹簧一样。
    </div>

<script>
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');
    const slider = document.getElementById('scaleSlider');
    const scaleValText = document.getElementById('scaleVal');
    const descText = document.getElementById('description');
    const radios = document.getElementsByName('mode');

    // 原始数据：三个关键帧 [Time(x), Value(y)] (Blender坐标系)
    // 我们会在绘制时映射到Canvas坐标
    // 手柄相对位置：[-15, 0] 左手柄, [15, 0] 右手柄
    const originalKeys = [
        { x: 100, y: 100, lh: {x: -30, y: 0}, rh: {x: 30, y: 0} }, // 左
        { x: 300, y: 200, lh: {x: -40, y: 0}, rh: {x: 40, y: 0} }, // 中
        { x: 500, y: 100, lh: {x: -30, y: 0}, rh: {x: 30, y: 0} }  // 右
    ];

    // 2D 游标位置 (Blender坐标)
    const cursor2D = { x: 50, y: 50 };

    let currentMode = 'bbox';
    let currentScale = 1.0;

    // 计算包围盒中心
    function getBBoxCenter(keys) {
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        keys.forEach(k => {
            if (k.x < minX) minX = k.x;
            if (k.x > maxX) maxX = k.x;
            if (k.y < minY) minY = k.y;
            if (k.y > maxY) maxY = k.y;
        });
        return { x: (minX + maxX) / 2, y: (minY + maxY) / 2 };
    }

    function draw() {
        // 清空背景
        ctx.fillStyle = "#2b2b2b";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 绘制网格
        ctx.strokeStyle = "#393939";
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i=0; i<canvas.width; i+=50) { ctx.moveTo(i,0); ctx.lineTo(i,canvas.height); }
        for(let i=0; i<canvas.height; i+=50) { ctx.moveTo(0,i); ctx.lineTo(canvas.width,i); }
        ctx.stroke();

        // 绘制坐标轴 (模拟Blender时间线)
        ctx.strokeStyle = "#111";
        ctx.beginPath();
        ctx.moveTo(0, canvas.height - 50);
        ctx.lineTo(canvas.width, canvas.height - 50);
        ctx.stroke();

        // 计算变换后的关键帧
        let transformedKeys = [];
        const bboxCenter = getBBoxCenter(originalKeys);

        originalKeys.forEach(k => {
            let newX = k.x;
            let newY = k.y;
            // 关键帧手柄 (Handle) 的世界坐标
            let hLx = k.x + k.lh.x;
            let hLy = k.y + k.lh.y;
            let hRx = k.x + k.rh.x;
            let hRy = k.y + k.rh.y;

            if (currentMode === 'bbox') {
                // 1. 包围盒模式：所有点绕 整体中心 缩放
                newX = bboxCenter.x + (k.x - bboxCenter.x) * currentScale;
                newY = bboxCenter.y + (k.y - bboxCenter.y) * currentScale;
                
                // 手柄也跟随整体缩放
                hLx = bboxCenter.x + (hLx - bboxCenter.x) * currentScale;
                hLy = bboxCenter.y + (hLy - bboxCenter.y) * currentScale;
                hRx = bboxCenter.x + (hRx - bboxCenter.x) * currentScale;
                hRy = bboxCenter.y + (hRy - bboxCenter.y) * currentScale;

            } else if (currentMode === 'cursor') {
                // 2. 游标模式：所有点绕 2D Cursor 缩放
                newX = cursor2D.x + (k.x - cursor2D.x) * currentScale;
                newY = cursor2D.y + (k.y - cursor2D.y) * currentScale;
                
                hLx = cursor2D.x + (hLx - cursor2D.x) * currentScale;
                hLy = cursor2D.y + (hLy - cursor2D.y) * currentScale;
                hRx = cursor2D.x + (hRx - cursor2D.x) * currentScale;
                hRy = cursor2D.y + (hRy - cursor2D.y) * currentScale;

            } else if (currentMode === 'individual') {
                // 3. 各自中心：关键帧位置不变！只有手柄绕着关键帧缩放
                newX = k.x;
                newY = k.y;

                // 手柄向量缩放
                hLx = newX + (k.lh.x * currentScale);
                hLy = newY + (k.lh.y * currentScale);
                hRx = newX + (k.rh.x * currentScale);
                hRy = newY + (k.rh.y * currentScale);
            }

            transformedKeys.push({
                x: newX, y: newY, 
                hl: {x: hLx, y: hLy},
                hr: {x: hRx, y: hRy}
            });
        });

        // 绘制 2D Cursor (仅在Cursor模式下高亮，但一直显示位置)
        drawCursor(cursor2D.x, canvas.height - cursor2D.y, currentMode === 'cursor');
        
        // 绘制 BBox Center (仅在BBox模式下高亮)
        if (currentMode === 'bbox') {
             drawPivot(bboxCenter.x, canvas.height - bboxCenter.y);
        }

        // 绘制曲线连接
        ctx.beginPath();
        ctx.strokeStyle = "#aaa";
        ctx.lineWidth = 2;
        // 简单模拟贝塞尔曲线视觉 (用直线连接关键帧方便理解位移)
        ctx.moveTo(transformedKeys[0].x, canvas.height - transformedKeys[0].y);
        for (let i = 0; i < transformedKeys.length - 1; i++) {
             // 简单的三次贝塞尔模拟
             let p0 = transformedKeys[i];
             let p1 = transformedKeys[i+1];
             ctx.bezierCurveTo(
                 p0.hr.x, canvas.height - p0.hr.y,
                 p1.hl.x, canvas.height - p1.hl.y,
                 p1.x, canvas.height - p1.y
             );
        }
        ctx.stroke();

        // 绘制关键帧和手柄
        transformedKeys.forEach(k => {
            let cy = canvas.height - k.y;
            let hly = canvas.height - k.hl.y;
            let hry = canvas.height - k.hr.y;

            // 手柄杆
            ctx.beginPath();
            ctx.strokeStyle = "#666";
            ctx.lineWidth = 1;
            ctx.moveTo(k.hl.x, hly);
            ctx.lineTo(k.x, cy);
            ctx.lineTo(k.hr.x, hry);
            ctx.stroke();

            // 手柄点
            ctx.fillStyle = "#da5c5c"; // 红色手柄
            ctx.beginPath(); ctx.arc(k.hl.x, hly, 3, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(k.hr.x, hry, 3, 0, Math.PI*2); ctx.fill();

            // 关键帧点 (橙色=选中)
            ctx.fillStyle = "#eb7d00";
            ctx.fillRect(k.x - 4, cy - 4, 8, 8);
            ctx.strokeStyle = "#fff"; // 选中高亮边框
            ctx.strokeRect(k.x - 4, cy - 4, 8, 8);
        });
    }

    function drawCursor(x, y, active) {
        ctx.strokeStyle = active ? "#ff4444" : "#555";
        ctx.lineWidth = 2;
        const size = 10;
        ctx.beginPath();
        // Crosshair
        ctx.moveTo(x - size, y); ctx.lineTo(x + size, y);
        ctx.moveTo(x, y - size); ctx.lineTo(x, y + size);
        ctx.stroke();
        // Circle
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, Math.PI*2);
        ctx.setLineDash([2, 2]);
        ctx.stroke();
        ctx.setLineDash([]);

        if(active) {
            ctx.fillStyle = "#fff";
            ctx.font = "12px Arial";
            ctx.fillText("2D Cursor", x + 15, y);
        }
    }

    function drawPivot(x, y) {
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI*2);
        ctx.fill();
        ctx.font = "12px Arial";
        ctx.fillStyle = "#aaa";
        ctx.fillText("Center", x - 20, y - 10);
    }

    // 事件监听
    slider.addEventListener('input', (e) => {
        currentScale = parseFloat(e.target.value);
        scaleValText.textContent = currentScale.toFixed(2);
        draw();
    });

    radios.forEach(r => {
        r.addEventListener('change', (e) => {
            currentMode = e.target.value;
            // 重置滑块以方便观察
            slider.value = 1.0;
            currentScale = 1.0;
            scaleValText.textContent = "1.0";
            
            // 更新描述
            if (currentMode === 'bbox') {
                descText.innerHTML = "选中了 <strong>包围盒中心</strong>。<br>注意看：关键帧向它们<strong>中间的那个点</strong>（Center）靠拢。这是调整整体幅度的首选。";
            } else if (currentMode === 'cursor') {
                descText.innerHTML = "选中了 <strong>2D 游标</strong>（左下角红十字）。<br>注意看：最左边的点也会移动！所有点都向游标靠拢。<br><strong>技巧：</strong> 把游标放在第0帧，用这个模式缩放，动画变快了但依然从0开始。";
            } else if (currentMode === 'individual') {
                descText.innerHTML = "选中了 <strong>各自中心</strong>。<br>注意看：<strong>橙色方块（关键帧）完全不动！</strong><br>只有红色的手柄在伸缩。这用于调整曲线的平滑度，而不改变时间点。";
            }
            draw();
        });
    });

    // 初始绘制
    draw();

</script>

</body>
</html>