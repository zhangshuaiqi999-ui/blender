<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Blender 曲线编辑器全能模拟器</title>
    <style>
        body {
            background-color: #181818;
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            margin: 0;
        }
        h2 { margin-bottom: 5px; color: #fff; }
        .subtitle { font-size: 0.9em; color: #aaa; margin-bottom: 20px; }
        
        /* 主容器 */
        .container {
            background-color: #2b2b2b;
            border: 1px solid #3d3d3d;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            width: 100%;
            max-width: 800px;
            padding: 20px;
            box-sizing: border-box;
        }

        /* 画布 */
        canvas {
            background: #222;
            border: 1px solid #111;
            border-radius: 4px;
            width: 100%;
            height: 350px; /* 固定高度 */
            display: block;
            margin-bottom: 20px;
            cursor: default;
        }

        /* 控制区网格 */
        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .panel {
            background: #333;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #444;
        }
        
        h4 { 
            margin: 0 0 10px 0; 
            padding-bottom: 5px;
            border-bottom: 2px solid #eb7d00;
            color: #fff;
            display: inline-block;
        }

        /* 单选按钮组 */
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        label {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: background 0.1s;
        }
        label:hover { background: #444; }
        input[type="radio"] {
            margin-right: 10px;
            accent-color: #eb7d00;
            transform: scale(1.2);
        }
        /* 禁用状态样式 */
        label.disabled { color: #555; cursor: not-allowed; }
        label.disabled:hover { background: none; }

        /* 滑块区域 */
        .slider-section {
            background: #252525;
            padding: 15px;
            border-radius: 6px;
            border-left: 5px solid #eb7d00;
        }
        .slider-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-weight: bold;
        }
        input[type="range"] {
            width: 100%;
            cursor: pointer;
            accent-color: #eb7d00;
        }

        /* 说明文字 */
        .description {
            margin-top: 15px;
            font-size: 14px;
            line-height: 1.5;
            color: #ccc;
        }
        .highlight { color: #eb7d00; font-weight: bold; }
        .tip { font-style: italic; color: #888; margin-top: 5px; font-size: 0.9em;}

    </style>
</head>
<body>

    <h2>Blender 曲线变换实验室</h2>
    <div class="subtitle">全能版：缩放 (S) / 移动 (G) / 旋转 (R) + 三种轴心模式</div>

    <div class="container">
        <canvas id="canvas" width="800" height="350"></canvas>

        <div class="controls-grid">
            <div class="panel">
                <h4>1. 选择操作 (Action)</h4>
                <div class="radio-group">
                    <label><input type="radio" name="action" value="scale" checked> 缩放 (Scale / S)</label>
                    <label><input type="radio" name="action" value="rotate"> 旋转 (Rotate / R)</label>
                    <label><input type="radio" name="action" value="move"> 移动 (Move / G)</label>
                </div>
            </div>

            <div class="panel">
                <h4>2. 选择轴心 (Pivot Point)</h4>
                <div class="radio-group" id="pivotGroup">
                    <label id="lbl-bbox"><input type="radio" name="pivot" value="bbox" checked> 包围盒中心 (Bounding Box Center)</label>
                    <label id="lbl-cursor"><input type="radio" name="pivot" value="cursor"> 2D 游标 (2D Cursor)</label>
                    <label id="lbl-individual"><input type="radio" name="pivot" value="individual"> 各自中心 (Individual Centers)</label>
                </div>
            </div>
        </div>

        <div class="slider-section">
            <div class="slider-header">
                <span id="sliderLabel">缩放倍数:</span>
                <span id="sliderVal" style="color:#eb7d00">1.00</span>
            </div>
            <input type="range" id="mainSlider" min="0" max="2.5" step="0.01" value="1.0">
            
            <div id="descText" class="description">
                加载中...
            </div>
        </div>
    </div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const slider = document.getElementById('mainSlider');
    const sliderLabel = document.getElementById('sliderLabel');
    const sliderVal = document.getElementById('sliderVal');
    const descText = document.getElementById('descText');
    const pivotLabels = {
        bbox: document.getElementById('lbl-bbox'),
        cursor: document.getElementById('lbl-cursor'),
        individual: document.getElementById('lbl-individual')
    };

    // 核心状态
    let state = {
        action: 'scale',     // scale, rotate, move
        pivot: 'bbox',       // bbox, cursor, individual
        value: 1.0           // slider value
    };

    // 2D 游标位置 (Blender 坐标系: 左下角为原点逻辑，但Canvas是左上角)
    // 我们在绘制层做Y轴翻转，这里存储逻辑坐标
    const CURSOR_POS = { x: 100, y: 100 }; 

    // 原始关键帧数据 (逻辑坐标)
    // 模拟一段“缓入缓出”的曲线
    const BASE_KEYS = [
        { x: 200, y: 150, lh: {x: -40, y: 0}, rh: {x: 40, y: 0} }, // Start
        { x: 400, y: 250, lh: {x: -40, y: 0}, rh: {x: 40, y: 0} }, // Middle (Peak)
        { x: 600, y: 150, lh: {x: -40, y: 0}, rh: {x: 40, y: 0} }  // End
    ];

    // 工具：计算包围盒中心
    function getBBoxCenter(keys) {
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        keys.forEach(k => {
            minX = Math.min(minX, k.x); maxX = Math.max(maxX, k.x);
            minY = Math.min(minY, k.y); maxY = Math.max(maxY, k.y);
        });
        return { x: (minX + maxX)/2, y: (minY + maxY)/2 };
    }

    // 工具：旋转点
    function rotatePoint(px, py, cx, cy, angleDeg) {
        const rad = angleDeg * Math.PI / 180;
        const cos = Math.cos(rad);
        const sin = Math.sin(rad);
        const dx = px - cx;
        const dy = py - cy;
        return {
            x: cx + dx * cos - dy * sin,
            y: cy + dx * sin + dy * cos
        };
    }

    // 更新 UI 状态（禁用/启用逻辑）
    function updateUIState() {
        // 读取 Radio
        document.getElementsByName('action').forEach(el => { if(el.checked) state.action = el.value; });
        document.getElementsByName('pivot').forEach(el => { if(el.checked) state.pivot = el.value; });
        state.value = parseFloat(slider.value);
        sliderVal.innerText = state.value.toFixed(2);

        // 特殊逻辑：Move 模式下，轴心点无效
        const isMove = state.action === 'move';
        for (let key in pivotLabels) {
            if (isMove) {
                pivotLabels[key].classList.add('disabled');
                pivotLabels[key].querySelector('input').disabled = true;
            } else {
                pivotLabels[key].classList.remove('disabled');
                pivotLabels[key].querySelector('input').disabled = false;
            }
        }

        // 更新文本和滑块范围
        updateDescription(isMove);
    }

    function updateDescription(isMove) {
        let txt = "";
        
        if (state.action === 'scale') {
            sliderLabel.innerText = "缩放系数:";
            if (state.pivot === 'bbox') {
                txt = "<strong>【包围盒中心 + 缩放】</strong><br>所有关键帧向整体中心靠拢。<br><span class='highlight'>用途：</span>整体调整动画的幅度或快慢（但不保证起始点位置）。";
            } else if (state.pivot === 'cursor') {
                txt = "<strong>【2D 游标 + 缩放】</strong><br>所有关键帧向红色游标靠拢。<br><span class='highlight'>用途：</span>如果你把游标放在第0帧，这是调整动画速度且<span class='highlight'>不改变起始时间</span>的最佳方法！";
            } else if (state.pivot === 'individual') {
                txt = "<strong>【各自中心 + 缩放】</strong><br>注意看：<strong>关键帧(橙色方块)没有动！</strong>只有红色手柄变长了。<br><span class='highlight'>用途：</span>想让动画曲线更夸张（S型更明显），但不想改变时间点时使用。";
            }
        } 
        else if (state.action === 'rotate') {
            sliderLabel.innerText = "旋转角度:";
            if (state.pivot === 'bbox') {
                txt = "<strong>【包围盒中心 + 旋转】</strong><br>整体绕中心旋转。<br><span class='highlight'>用途：</span>较少用于调节节奏，多用于特殊图形构造。";
            } else if (state.pivot === 'cursor') {
                txt = "<strong>【2D 游标 + 旋转】</strong><br>整体绕游标旋转。<br><span class='highlight'>用途：</span>创造线性的数值倾斜（比如让物体匀速上升的同时带有波动）。";
            } else if (state.pivot === 'individual') {
                txt = "<strong>【各自中心 + 旋转】</strong><br>注意看：<strong>关键帧没有动！</strong>它们只是原地“扭”了一下手柄。<br><span class='highlight'>用途：</span>这是调节<span class='highlight'>入场/出场缓急（Ease-in/out）</span>的神技。坡度变平=刹车变慢；坡度变陡=加速变快。";
            }
        } 
        else if (state.action === 'move') {
            sliderLabel.innerText = "移动距离:";
            txt = "<strong>【移动 (Grab)】</strong><br><span class='highlight'>注意：Blender 中移动操作不受轴心点影响！</span><br>无论你选什么轴心，G 键总是整体平移。<br>左右拖动 = 改变发生的时间；上下拖动 = 改变数值大小。";
        }

        descText.innerHTML = txt;
    }

    // 绘制逻辑
    function draw() {
        // 清空
        ctx.fillStyle = "#222";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // 绘制网格
        drawGrid();

        // 确定 Pivot 坐标
        let pivot = {x:0, y:0};
        const bbox = getBBoxCenter(BASE_KEYS);
        
        if (state.pivot === 'bbox') pivot = bbox;
        else if (state.pivot === 'cursor') pivot = CURSOR_POS;
        // individual 不需要单一 pivot

        // 计算变换后的点
        let transformedKeys = BASE_KEYS.map(k => {
            let newK = JSON.parse(JSON.stringify(k)); // Deep copy

            // --- 移动 (Move) ---
            if (state.action === 'move') {
                // Move 忽略 Pivot，直接加 Offset
                // 模拟 G -> X (时间平移)
                newK.x += state.value; 
                // 手柄随之移动
                // (Y轴我们暂不演示，专注演示X轴时间平移)
            } 
            
            // --- 缩放 (Scale) ---
            else if (state.action === 'scale') {
                const s = state.value;
                if (state.pivot === 'individual') {
                    // 各自中心：只缩放手柄向量
                    newK.lh.x *= s; newK.lh.y *= s;
                    newK.rh.x *= s; newK.rh.y *= s;
                } else {
                    // 绕 Pivot 缩放位置
                    newK.x = pivot.x + (k.x - pivot.x) * s;
                    newK.y = pivot.y + (k.y - pivot.y) * s;
                    // 手柄长度也要缩放以保持形状
                    newK.lh.x *= s; newK.lh.y *= s;
                    newK.rh.x *= s; newK.rh.y *= s;
                }
            }
            
            // --- 旋转 (Rotate) ---
            else if (state.action === 'rotate') {
                const r = state.value;
                if (state.pivot === 'individual') {
                    // 各自中心：只旋转手柄向量
                    // 必须把手柄向量当做点旋转
                    let newL = rotatePoint(k.lh.x, k.lh.y, 0, 0, r);
                    let newR = rotatePoint(k.rh.x, k.rh.y, 0, 0, r);
                    newK.lh = newL;
                    newK.rh = newR;
                } else {
                    // 绕 Pivot 旋转位置
                    let pRot = rotatePoint(k.x, k.y, pivot.x, pivot.y, r);
                    newK.x = pRot.x; newK.y = pRot.y;
                    // 手柄向量也要旋转
                    let newL = rotatePoint(k.lh.x, k.lh.y, 0, 0, r);
                    let newR = rotatePoint(k.rh.x, k.rh.y, 0, 0, r);
                    newK.lh = newL;
                    newK.rh = newR;
                }
            }

            return newK;
        });

        // 绘制辅助线 (Pivot) - Move模式下不绘制Pivot因为无效
        if (state.action !== 'move') {
            if (state.pivot === 'cursor') drawPivot(CURSOR_POS, "2D 游标", "#ff4444");
            if (state.pivot === 'bbox') drawPivot(bbox, "包围盒中心", "#ffffff");
        }

        // 绘制曲线
        drawCurve(transformedKeys);
    }

    function toCanvasY(y) {
        return canvas.height - y; // 翻转Y轴
    }

    function drawGrid() {
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i=0; i<canvas.width; i+=50) { ctx.moveTo(i,0); ctx.lineTo(i,canvas.height); }
        for(let i=0; i<canvas.height; i+=50) { ctx.moveTo(0,i); ctx.lineTo(canvas.width,i); }
        ctx.stroke();
        
        // 地面线
        ctx.strokeStyle = "#111";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, toCanvasY(0)); ctx.lineTo(canvas.width, toCanvasY(0));
        ctx.stroke();
    }

    function drawPivot(pos, label, color) {
        const cx = pos.x;
        const cy = toCanvasY(pos.y);
        ctx.strokeStyle = color;
        ctx.setLineDash([4, 2]);
        ctx.lineWidth = 1;
        
        // 十字准星
        ctx.beginPath();
        ctx.moveTo(cx-15, cy); ctx.lineTo(cx+15, cy);
        ctx.moveTo(cx, cy-15); ctx.lineTo(cx, cy+15);
        ctx.stroke();
        
        // 圆圈
        ctx.beginPath();
        ctx.arc(cx, cy, 10, 0, Math.PI*2);
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.fillStyle = color;
        ctx.font = "12px Arial";
        ctx.fillText(label, cx + 15, cy - 15);
    }

    function drawCurve(keys) {
        // 连线
        ctx.strokeStyle = "#eb7d00"; // Blender 橙
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(keys[0].x, toCanvasY(keys[0].y));

        for (let i = 0; i < keys.length - 1; i++) {
            const p0 = keys[i];
            const p1 = keys[i+1];
            
            // 贝塞尔控制点 (绝对坐标)
            const cp1x = p0.x + p0.rh.x;
            const cp1y = toCanvasY(p0.y + p0.rh.y);
            const cp2x = p1.x + p1.lh.x;
            const cp2y = toCanvasY(p1.y + p1.lh.y);
            const endX = p1.x;
            const endY = toCanvasY(p1.y);

            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
        }
        ctx.stroke();

        // 绘制关键帧点和手柄
        keys.forEach(k => {
            const kx = k.x;
            const ky = toCanvasY(k.y);
            
            // 左手柄
            const lhx = kx + k.lh.x;
            const lhy = toCanvasY(k.y + k.lh.y);
            // 右手柄
            const rhx = kx + k.rh.x;
            const rhy = toCanvasY(k.y + k.rh.y);

            // 杆
            ctx.strokeStyle = "#666";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(lhx, lhy); ctx.lineTo(rhx, rhy);
            ctx.stroke();

            // 手柄头 (红)
            ctx.fillStyle = "#da5c5c";
            ctx.beginPath(); ctx.arc(lhx, lhy, 3, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(rhx, rhy, 3, 0, Math.PI*2); ctx.fill();

            // 关键帧 (橙)
            ctx.fillStyle = "#eb7d00";
            ctx.fillRect(kx - 5, ky - 5, 10, 10);
            ctx.strokeStyle = "white";
            ctx.strokeRect(kx - 5, ky - 5, 10, 10);
        });
    }

    // 事件监听
    document.querySelectorAll('input[type=radio]').forEach(r => {
        r.addEventListener('change', (e) => {
            // 切换Action时重置滑块范围和默认值
            const action = document.querySelector('input[name="action"]:checked').value;
            
            if (action === 'scale') {
                slider.min = 0; slider.max = 2.0; slider.step = 0.01; slider.value = 1.0;
            } else if (action === 'rotate') {
                slider.min = -45; slider.max = 45; slider.step = 1; slider.value = 0;
            } else if (action === 'move') {
                slider.min = -150; slider.max = 150; slider.step = 1; slider.value = 0;
            }
            
            updateUIState();
            draw();
        });
    });

    slider.addEventListener('input', () => {
        updateUIState();
        draw();
    });

    // 初始化
    updateUIState();
    draw();

</script>

</body>
</html>