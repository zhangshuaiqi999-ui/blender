# 着色器节点，全部都是场，各种 bsdf 就是计算的起点，是在倒着获取数据。

虽然都是场，但是也区分常量数据节点和函数节点。

# 所有关于坐标的操作的结果，都是对应原坐标的一个标记值。

原坐标永远不变和存在。但是对应的标记值会经历一些节点链路组成的函数映射。这个函数映射就是原坐标和标记值的对应关系。

# 很多纹理节点，都是放大显得密度大，缩小变得密度小。

这个时候的缩放，是节点的 scale 参数也好，还是放大或者缩小某个轴上的值，都可以看作在放大或者缩小频率。同样的面积上显示的东西多(频率大)，就密度大，个体小；显示的东西少（频率少），就密度小，个体大。

# Factor-因子，都可以被当作遮罩来处理东西。

# 操作vector的话，使用 math的add节点与 vector的 math节点，是否效果一致？

**绝对不一致，效果天差地别。**

这是一个非常经典且容易“踩坑”的问题。对于你（Shuaiqi-Z）现在的技术美术（Tech Art）学习阶段，理解这个区别至关重要。

简单来说：

- **Vector Math (向量运算)** 是 **“三车道并行”**。
- **Math (数学运算)** 是 **“三车道并一车道”**。

------

## 1. 核心区别图解

假设你有两个向量：

- 向量 A：![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768800009955-613b65a2-a008-443d-9840-c134cdbdad95.png) （只有 X 轴有值）
- 向量 B：![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768800009882-43dfcec0-ba61-4166-9c75-5264c80b96f2.png) （只有 Y 轴有值）

我们来看看做 **ADD（相加）** 时会发生什么：

### ✅ 情况一：使用 `Vector Math` (蓝色节点)

它会老老实实地把 X 加 X，Y 加 Y，Z 加 Z。

- ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768800009876-8a2ade16-5e7d-4184-8079-6b7a345ce21a.png)
- ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768800009874-f06902aa-d8c9-4226-a947-1599524e1b8a.png)
- ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768800010031-bdbff70e-3c3f-45da-bc99-7fd97e93ca5d.png)
- **结果**：![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768800010072-eb45079b-37f7-4671-9b0d-bc66a96f37dc.png)
- **视觉效果**：两个方向力叠加了，保留了空间方向。

### ❌ 情况二：使用 `Math` (灰色节点)

当你把蓝色的向量连到灰色的 Math 节点时，Blender 会强制把向量 **“压扁”成一个数字（Float）**。

- 转化规则通常是取平均值：![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768800010099-9e743f4c-9f05-46e6-bd1b-94362c9a9e35.png)

- 向量 A 变成：![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768800010102-9b59d41c-c822-4bd2-b1b5-a83368d5d156.png)
- 向量 B 变成：![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768800010261-90f4af56-9f6f-4869-b688-0a055124c75b.png)

- 然后相加：![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768800010341-6ba2805d-1e95-483a-90ac-7e0375347150.png)
- **结果**：![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768800010369-41cecea0-43cb-4fda-9c69-091129a1ddfd.png) （这就变成了一个标量，没有方向了！）
- **视觉效果**：如果你再把它连回向量口，它会变成 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768800010432-a33f06c0-305c-4af0-84a1-7a602f383c88.png)。原本的 X 和 Y 轴特征全丢了，变成了一个均匀的灰色。

------

## 2. 怎么一眼区分？看插口颜色

Blender 的节点设计是通过颜色来警告你的：

- **🔵** **蓝色插口 (Vector)**：包含 X, Y, Z 三个数据。
- **⚪** **灰色插口 (Float/Value)**：只包含 1 个数据。

**黄金法则：**

如果你在处理坐标（Coordinate）、法线（Normal）或者位置（Position），**永远只用蓝色的 Vector Math**。

一旦你中间串了一个灰色的 Math 节点，你的三维信息瞬间就“降维打击”变成一维了。

## 3. 有例外吗？

只有一种情况它们看起来“差不多”：

当你处理的是 **黑白图** 或者 **均匀数值**（比如 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768800010398-7ca89f14-7efd-47b0-9a2d-f9f17929c252.png)）时，因为 X=Y=Z，所以分开算和合起来算结果一样。

但在这一行的专业操作里，**请严格区分**，养成“蓝连蓝，灰连灰”的好习惯。

# 纯黑白，rgb 通道中的值是相等的。

单值（黑白值）-->rgb 通道，是将三个通道中的值设置为相同。

rgb 三值，转化为单值（黑白值）会损失数据精度。

# blender 5.0着色器节点是不是所有的输入参数，都有可能配合遮罩来进行非线性不规则的处理？

**答案是：99% 的情况下，是的。**

这是一个非常敏锐的观察。你正在触摸到 Blender 节点系统最强大的核心逻辑：**“一切皆数据，一切皆可映射”**。

只要你在参数左边看到一个**小圆点（插孔/Socket）**，无论它原本是一个滑块、一个颜色条还是一个数值，它都可以被“遮罩”（纹理/数学节点）接管，从而实现你所说的“非线性、不规则的处理”。

我们可以把这个规则总结为 **“插孔定律”**。

### 1. 什么是“插孔定律”？

在 Shader Editor 中，参数分为两类：

#### A. 带插孔的参数 (The Mappable Ones) —— 可被遮罩驱动

- **特征：** 左边有灰色、黄色、紫色或绿色的**小圆点**。
- **例子：**

- `Roughness` (粗糙度)：可以用遮罩让物体“有的地方亮，有的地方哑光”。
- `Metallic` (金属度)：可以用遮罩让物体“有的地方是锈（非金属），有的地方是铁（金属）”。
- `IOR` (折射率)：可以用遮罩让玻璃“有的地方折射强，有的地方折射弱”。
- `Transmission` (透光率)：可以用遮罩让物体“有的地方透明，有的地方不透明”。
- 甚至 `Normal` (法线)：可以用遮罩控制凹凸的强弱。

- **结论：** 凡是有插孔的，都可以插上一张“黑白图”或“彩色图”，让这个参数在模型表面发生**不规则的变化**。

#### B. 不带插孔的参数 (The Switches) —— 不可被遮罩驱动

- **特征：** 只有下拉菜单、复选框或纯文字。
- **例子：**

- `Distribution` (分布方式)：GGX / Beckmann。你不能让物体左边用 GGX，右边用 Beckmann。
- `Subsurface Method` (次表面方法)：Christensen-Burley / Random Walk。
- `Clamp` (钳制) 复选框。

- **结论：** 这些是“开关”或“算法选择”，必须对整个材质统一生效。

------

### 2. “非线性”与“不规则”是如何实现的？

你提到的**“非线性不规则”**，其实包含了两层含义，Blender 是这样处理的：

#### 第一层：空间上的不规则 (Spatially Varying)

这是由 **纹理 (Texture)** 决定的。

- 当你把一张 **噪波纹理 (Noise Texture)** 连到 `Roughness` 上。
- 噪波本身是乱的（不规则的）。
- 于是，Roughness 就在模型表面变得乱七八糟。

#### 第二层：数值上的非线性 (Non-linear Value Mapping)

这是由 **中间的数学节点** 决定的。

- 假设你的遮罩是 0 到 1 的线性渐变。
- 如果你直接连进去，Roughness 就是 0 到 1 线性变化。
- **非线性处理：** 你在中间加一个 `**RGB Curves**` **(曲线)** 或者 `**Gamma**` 节点。
- **结果：** 你改变了输入信号的“手感”。比如让大部分区域都很粗糙，只有极少部分突然变得很光滑。

### 3. 一个极端的例子：IOR (折射率)

普通人只设一个 IOR = 1.45 (玻璃)。

但你可以插一张黑白遮罩进 `IOR`：

- **黑色区域 (0.0):** IOR 变成 0（完全没有折射，可能看起来像空气或穿帮）。
- **白色区域 (1.0):** IOR 变成 1（空气）。
- **灰色区域 (1.45):** 正常的玻璃。
- **甚至更疯狂：** 配合 `Map Range` 节点，让 IOR 在 1.1 到 2.5 之间根据纹理随机跳变。
- **效果：** 你会得到一块“密度极度不均匀、充满了内应力和杂质”的魔幻水晶。

### 总结

Blender 着色器的哲学是：**不要只把参数当成一个固定的数字。**

- 每一个带圆点的参数，本质上都是在等待一张**地图 (Map)**。
- 这张地图告诉 Blender：“在模型的这个像素点上，这个参数的值是多少。”

所以，你的理解完全正确。所有的插孔，配合纹理（Mask）和数学节点（Math/Curves），都可以进行随心所欲的、非线性的、不规则的艺术化处理。

## 将这99%和1%精准的区分开

好的，这是为您专门整理的 **Blender 5.0 版本（基于 Principled BSDF 2.0 架构）** 专属的 **“99% vs 1% 精准分离手册”**。

在 Blender 5.0 中，官方引入了大量的 **"Weight"（权重）** 参数，这实际上大大扩大了“绿区”的范围。现在的逻辑比以前更清晰：**除了几个特定的物理死角，其他所有地方都在暗示你插入遮罩。**

------

### 🚦 第一类：绿区 (The 99%) —— 随意狂连

**特征：** 插孔颜色为 **⚪** **灰色 (Float/Weight)** 或 **🟡** **黄色 (Color)**。

**判定：****直接插！** 所有的黑白遮罩、噪波、非线性曲线处理，在这里都是合法的，而且是官方推荐的。

#### 1. 核心材质属性 (Core)

- **Base Color (****🟡****):**

- *5.0 变化：***它是双重身份。** 它既是表面的漫反射颜色，也是次表面散射 (SSS) 的颜色（原来的 `Subsurface Color` 被移除了）。
- *玩法：* 插纹理控制哪里是红色的肉，哪里是白色的骨头。

- **Metallic (****⚪****):** 只有 0 和 1（黑或白），必须用遮罩区分金属/非金属。
- **Roughness (****⚪****):****灵魂参数。** 必须插遮罩（指纹、划痕、污渍）。
- **IOR (****⚪****):** 折射率。可以插遮罩做材质密度不均的效果。

#### 2. “权重”家族 (The Weight Family - 5.0 新主力)

*Blender 5.0 把很多混合滑块改名为了 "Weight"，专门用来接遮罩。*

- **Subsurface Weight (****⚪****):**

- *替代了旧版的 Subsurface (0-1)。*
- *玩法：* 插遮罩控制透光区域。例如：耳朵边缘是白（透光），脸颊中间是黑（不透光）。

- **Transmission Weight (****⚪****):**

- *替代了旧版的 Transmission。*
- *玩法：* 插遮罩控制哪里是透明玻璃，哪里是磨砂或不透明标签。

- **Coat Weight (****⚪****):**

- *玩法：* 插遮罩做“局部打湿”或“局部清漆”效果。

- **Sheen Weight (****⚪****):**

- *玩法：* 插遮罩控制哪里有天鹅绒般的边缘反光（比如布料磨损处）。

- **Emission Strength (****⚪****):** 自发光强度。插遮罩做科幻呼吸灯。

#### 3. 高光控制 (Specular 新逻辑)

- **IOR Level (****⚪****):**

- *替代了旧版的 Specular。*
- *玩法：* 依然是 **绿区**。插遮罩控制物体表面的微观反射率（比如灰尘区域反光弱，油渍区域反光强）。

------

### ⚠️ 第二类：黄区 (需转译) —— 必须加中间节点

**特征：** 插孔颜色为 **🟣** **紫色 (Vector/Normal)**，但你手里只有黑白/灰度遮罩。

**判定：****禁止直连！** 必须加 **Bump Node**。

- **Normal (****🟣****):**

- *Blender 5.0 现状：* 全局法线。
- *操作：* 黑白图 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768209883447-6b8f7d6e-8300-46a0-b34d-dc811aae8348.png) Height (Bump节点) ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768209883957-20e7adb8-cb3d-49f6-a3aa-78460f131a9b.png) Normal。

- **Coat Normal (****🟣****) [新]:**

- *5.0 新增：* 专门用于清漆层的法线。
- *玩法：* 比如底下的 `Normal` 是砖墙凹凸，表面的 `Coat Normal` 是一层平滑的水膜（或者带点水波纹）。**必须通过 Bump 节点连接。**

------

### ❌ 第三类：红区 (The 1%) —— 物理算法禁区

**特征：** 插孔通常为 **🟣** **紫色** 或 **特殊的三色组合**。

**判定：****算法敏感区。** 这里如果输入高频、剧烈的随机噪波（即“非线性不规则处理”），会导致渲染错误、噪点或物理失效。

#### 1. Subsurface Radius (🟣 或三个数值)

- **定义：** 光线在红绿蓝三个波段下能在物体内部跑多远。
- **为何禁止：** SSS 是基于模糊算法的。
- **后果：** 如果你在这里插一张高对比度的噪波（比如这一像素半径 1米，下一像素 0米），渲染器会产生严重的 **萤火虫噪点 (Fireflies)**，且难以计算收敛。
- **适用范围：** 仅接受**平滑**的变化，不接受高频不规则处理。

#### 2. Tangent (🟣)

- **定义：** 决定各向异性（Anisotropic）高光的拉丝方向。
- **为何禁止：** 它是向量场。
- **后果：** 如果插噪波，高光会碎成渣，拉丝效果完全消失。
- **适用范围：** 只能插 **Tangent 节点** 或专门制作的流向图 (Flow Map)。

#### 3. Displacement (🟣 - 在材质输出节点 Output 上)

- **定义：** 真实的几何置换。
- **为何警告：** 这是一个半红区。
- **后果：** 如果直接插一个边缘极其锋利（没有过渡）的黑白图，模型网格会**撕裂** (Tearing) 或产生极长的尖刺。
- **修正：** 必须在遮罩和插孔之间加一个模糊处理，或者使用 `Map Range` 开启 `Smooth Step` 保证数值有过渡。

------

### 📝 Blender 5.0 最终速查表

| **插孔名称 (5.0)**  | **颜色** | **你的动作 (非线性处理)** | **判定**     | **理由**                                       |
| ------------------- | -------- | ------------------------- | ------------ | ---------------------------------------------- |
| **Base Color**      | 🟡        | 插纹理/遮罩               | ✅ **通过**   | 颜色/SSS颜色二合一，随便玩。                   |
| **Metallic**        | ⚪        | 插纹理/遮罩               | ✅ **通过**   | 决定哪里是铁。                                 |
| **Roughness**       | ⚪        | 插纹理/遮罩               | ✅ **通过**   | **必须插！** 真实感的来源。                    |
| **Weight 系列**     | ⚪        | 插纹理/遮罩               | ✅ **通过**   | (Subsurface/Coat/Sheen/Trans) 官方指定遮罩口。 |
| **IOR / IOR Level** | ⚪        | 插纹理/遮罩               | ✅ **通过**   | 控制折射/反光强度。                            |
| **Normal**          | 🟣        | 插黑白图                  | ⚠️ **需转译** | **必须加 Bump 节点**。                         |
| **Coat Normal**     | 🟣        | 插黑白图                  | ⚠️ **需转译** | **必须加 Bump 节点**。                         |
| **Radius (SSS)**    | 🟣        | 插高频噪波                | ❌ **禁止**   | 会导致渲染噪点/伪影。                          |
| **Tangent**         | 🟣        | 插随机噪波                | ❌ **禁止**   | 会破坏拉丝效果。                               |

**总结：**

在 Blender 5.0 里，只要你避开 **Radius** 和 **Tangent** 这两个物理硬茬，其他的插孔（尤其是所有的 **Weight** 和 **Roughness**），请尽情地使用遮罩进行“非线性不规则处理”。

# Bump-凹凸

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768044062012-279561de-f759-496b-8e44-baff48e23c3d.png)

它的主要作用是**模拟物体表面的细节**（如划痕、毛孔、凸起），但**并不真正改变模型的几何形状（网格）**。它利用光影的计算欺骗眼睛，让平面看起来有立体感。

### 核心原理

它将灰度图像（黑白图）转换为“法向（Normal）”数据：

- **白色**区域代表凸起（高峰）。
- **黑色**区域代表凹陷（低谷）。

### 参数详细解释

- **Invert (反转):**

- 勾选后，原本凸起的地方会变成凹陷，反之	亦然。

- **Strength (强度):**

- 控制凹凸效果的明显程度。
- `0.0` 表示没有效果，`1.0` 表示最强效果。

- **Distance (距离):**

- 这是最关键但也最容易被设置错误的参数。它控制凹凸的**模拟高度**（以米为单位）。
- *建议：* 如果你的材质看起来黑黑的、或者光影很奇怪，通常是因为这个值太大了。试着把它调小，比如 `0.1` 甚至 `0.01`。

- **Filter Width (过滤宽度):**

- *这是 Blender 4.4/5.0 新增的重要功能。* 它控制凹凸计算的“锐利度”。
- **数值小 (0.1):** 细节非常锐利。适合高分辨率贴图。
- **数值大:** 会模糊处理细节。如果你的贴图像素太低（有马赛克），或者你想模拟那种边缘比较圆润的倒角效果，可以调大这个值。

- **Height (高度):**

- 输入端。这里连接你的黑白贴图（如噪波纹理 Noise Texture 或图片纹理）。

- **Normal (法向):**

- 输入端。用于串联多个法向节点（通常很少用到这个输入）。
- **输出端（右侧紫色点）**：连接到主材质节点（如 *Principled BSDF/原理化 BSDF*）的 **Normal** 插槽。

### 如何使用？

1. 添加一个纹理（例如 **Noise Texture / 噪波纹理**）。
2. 将纹理的颜色或系数（Fac）连到 Bump 节点的 **Height (高度)**。
3. 将 Bump 节点的 **Normal (法向)** 输出连到 **Principled BSDF** 的 **Normal**。

## Distance 和 Height 的关系？

这是一个非常经典且容易混淆的问题，特别是在调节材质凹凸感时。

简单直接的回答是：

`**Height**` **是“地形图”（哪里高哪里低），**`**Distance**` **是“比例尺”（最高能有多高）。**

下面我们详细拆解它们的区别：

### 1. Height (高度) —— 它是“数据来源”

注意看，`Height` 左边有一个灰色的圆点（接口）。这说明它主要是一个**输入端**，用来接收纹理数据的。

- **作用：** 它告诉 Blender **“纹理的形状是什么样的”**。
- **输入内容：** 通常是一张黑白图（或者噪波纹理）。

- **黑（0）：** 代表最低点（坑底）。
- **白（1）：** 代表最高点（山顶）。
- **灰（0.5）：** 代表半山腰。

- **性质：** 它是**相对的**。它只定义了起伏的“趋势”和“图案”，但没有定义具体的物理高度。

### 2. Distance (距离) —— 它是“物理单位”

注意看，`Distance` 是一个具体的**数值滑块**（通常单位是米）。

- **作用：** 它告诉 Blender **“黑白图里的白色，到底代表现实世界中的几米？”**
- **物理含义：** 这是一个**世界单位**的数值。

- 如果你设置 `Distance = 1m`：那么 Height 输入里的纯白色（1.0），就会被模拟成凸起 **1米** 的效果。
- 如果你设置 `Distance = 0.01m` (1厘米)：那么 Height 输入里的纯白色，只会被模拟成凸起 **1厘米** 的微小细节。

- **性质：** 它是**绝对的**。它赋予了黑白图真实的物理深度感。

------

### 一个通俗的比喻：绘制地图

想象你要给瞎子做一张 **立体地图**：

1. **Height (输入)：** 就像是你手里的那张**图纸**。上面画了等高线，告诉我们在哪里有山，哪里有河，山谷的形状是圆的还是尖的。

- *（没有图纸，你就不知道哪里该凸起）*

1. **Distance (数值)：** 就像是你做立体地图时选用的**材料厚度**。

- 如果你告诉制造机器：“最大高度是 1000米”。做出来的地图就像珠穆朗玛峰一样极其陡峭。
- 如果你告诉制造机器：“最大高度是 1米”。虽然山的形状（Height）还在，但做出来的地图看起来就像是一个微微隆起的小土坡。

### 3. 实战中怎么用？

这也是新手最容易犯错的地方：**不要用 Strength（强度）来调节高度，要用 Distance！**

- **错误的用法：**

Distance 保持默认的 1.0 (1米)，然后觉得太深了，把 Strength 降到 0.01。

- *后果：* 虽然看起来变平了，但物理计算是错的。光影会觉得怪怪的。

- **正确的用法（物理正确）：**

1. 先把 **Strength** 设为 **1.0**（全开）。
2. 思考你做的东西表面的凹凸到底有多深？

- 如果是 **瓷砖缝隙**：大概 5毫米。那就把 **Distance 设为 0.005**。
- 如果是 **皮肤毛孔**：大概 0.2毫米。那就把 **Distance 设为 0.0002**。
- 如果是 **月球环形山**：可能几百米。那就设为 500。

1. 最后连上 **Height** 纹理。

### 总结

- **Height (接口)：** 给**图案**。回答“**哪里**凸起？”
- **Distance (参数)：** 给**深度**。回答“凸起**多少米**？”
- **Strength (滑块)：** 是一个混合因子。用来微调或者淡化整体效果（0=没效果，1=完全应用 Distance 的设定）。

## Strength ，是对Distance的调节吗？是类似与透明度？

**太精准了！你的直觉非常棒。**

把 `Strength` 理解为图层里的 **“不透明度 (Opacity)”** 或者 **“混合度 (Fac)”** 是最完美的类比。

虽然从最终结果上看，调节 `Strength` 和调节 `Distance` 都会让凹凸感变强或变弱，但它们的**底层逻辑**和**使用场景**完全不同。

我们可以这样区分：

### 1. 核心类比：图片处理软件

想象你在 Photoshop 里给一张平滑的灰纸（原始法线）上面叠了一层“皱纹图层”（Bump 效果）。

- **Distance (距离) = 图层的“内容绘制强度”**

这就像是你画皱纹时，笔触下得有多重。你是画了深深的沟壑（Distance大），还是画了浅浅的划痕（Distance小）。**这是物理属性。**

- **Strength (强度) = 图层的“不透明度”**

这就像是你画好之后，觉得太突兀了，于是把这个图层的透明度从 100% 拉到了 50%。你并没有改变皱纹原本画的深度，只是让它**显示得不那么明显**，或者把它和底下的平滑表面进行**混合**。

### 2. 数学上的“偷懒公式”

虽然它们逻辑不同，但在 Blender 的计算中，它们确实是**乘法关系**。

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768205264708-2620fd75-357e-4ffa-a9fe-e0577d2bad91.png)

这意味着：

- **设置 A：** Distance = 1.0米，Strength = 0.1 (10%) ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768205264609-2cc45413-99df-4a59-ad55-f7af80e74002.png) 结果是 0.1米。
- **设置 B：** Distance = 0.1米，Strength = 1.0 (100%) ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768205264626-995859d2-8507-405f-968e-d3215f8363b8.png) 结果也是 0.1米。

**虽然结果一样，但千万不要混用！**

### 3. 为什么要区分这两个？（最佳实践）

你可能会问：“既然结果一样，我为什么不把 Distance 永远设为 1，只调 Strength 就好了？”

**这是新手最容易踩的坑。** 请遵循以下原则：

#### **Distance：用来定“物理事实”**

你要问自己：这个东西真实世界里有多深？

- 如果做**砖墙**，缝隙深 1cm，那 Distance 就必须填 **0.01**。
- 如果做**毛孔**，深 0.2mm，那 Distance 就必须填 **0.0002**。
- *这一步是确立物理上的真实性。*

#### **Strength：用来做“艺术微调”**

当你设定好真实的 Distance 后，渲染出来发现：“哎呀，虽然物理是对的，但在现在的光照下看起来有点太乱了，或者我想让它隐约一点。”

- 这时候，你才去动 **Strength**。
- 把它降到 0.8 或 0.5，让效果更柔和。
- 或者当你使用纹理贴图控制局部（有些地方有凹凸，有些地方没有）时，你会把遮罩图连在 Strength 上。

### 总结

- **Distance** 是 **“造型师”**：决定了这个坑实际上挖了多深。
- **Strength** 是 **“调光师”**：决定了这个坑我们要看多清楚（类似透明度）。

**操作建议：**

永远先设置正确的 **Distance**（符合真实物理尺寸），保持 Strength 为 1。只有在为了艺术效果需要减弱时，才去降低 Strength。

# Mapping-映射

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768048984194-e7f88836-c142-4500-9d0f-2f62c5a0111b.png)![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768093386098-2e3fff39-31ca-4afa-8943-091097e891bd.png)![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768093399254-21b7a1da-9934-45ac-afa5-18c7ed49ab7b.png)![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768093415834-8694d1c8-a196-4976-99c2-dfcefc5441db.png)

这张截图展示的是 Blender 中非常核心且常用的 **Mapping（映射）节点**。虽然你提到了 Blender 5.0，但这个节点的核心逻辑在 Blender 3.x、4.x 以及未来的版本中都是保持一致的。

它的主要作用是**对纹理坐标（Texture Coordinates）进行变换**，简单来说，就是控制贴图在模型表面的**平移（位置）、旋转和缩放**。

以下是该节点的详细参数解析：

### 1. 顶部下拉菜单：Type（类型）

这是最容易被忽视但非常重要的选项，它决定了变换的计算方式：

- **Point（点 - 默认值）：**

  - **用途：** 最常用的模式。它将输入的向量视为空间中的一个“点”。

  - **效果：** 这里的变换是直观的。比如你在 Location X 输入 1，纹理坐标就会沿 X 轴移动。这通常用于 UV 贴图或生成的纹理坐标。

- **Texture（纹理）：**

  - **用途：** 将变换应用于纹理本身，而不是坐标系。

  - **区别：** 它的逻辑是反向的。如果你在这里将 Location 移动 +1，纹理实际上会向反方向移动。这是为了模拟“移动纹理框”而不是“移动点”的感觉。

- **Vector（向量）：**

  - **用途：** 用于处理方向向量（Direction Vectors）。

  - **特点：** 在这种模式下，**Location（位置）参数会失效**，因为向量只有方向和大小，没有位置概念。通常用于变换法线贴图以外的数学向量。

- **Normal（法向）：**
  - **用途：** 专门用于变换法线向量。它会应用此时的缩放和旋转，并进行归一化处理（保持长度为1），确保法线方向正确。

### 2. 左侧输入端口 (Inputs)

- **Vector（紫色圆点）：**

  - 这是**必须连接**的端口（虽然不连也有默认值，但通常没意义）。

  - **通常连接：**`Texture Coordinate`（纹理坐标）节点的输出，比如 UV、Generated（生成）、Object（物体）等。

  - **如果不连：** 默认输入坐标为 (0,0,0)，这会导致纹理变成单色或消失。

- **Location / Rotation / Scale（下方三个紫色圆点）：**
  - 这些端口允许你通过其他节点（如 `Value` 节点或驱动器）来动态控制变换参数。如果不连接线，就直接使用节点中间的数字框。

### 3. 中间变换参数 (Transform)

这是你实际操作最多的区域：

- **Location（位置/平移）：**

  - 控制纹理在 X、Y、Z 轴上的移动。

  - *在 2D 贴图中，通常只调整 X 和 Y。*

- **Rotation（旋转）：**

  - 控制纹理的旋转角度。

  - *注意：旋转是基于坐标原点进行的（通常是 UV 的 0,0 点或物体的原点）。*

- **Scale（缩放）：**

  - 控制纹理的大小。

  - **关键概念：** 如果你把 Scale 设置为 **5**，意味着纹理会在单位面积内**重复 5 次**。所以，**数值越大，纹理看起来越密集（越小）；数值越小，纹理看起来越大。**

### 4. 右侧输出端口 (Output)

- **Vector：**

- 输出经过变换后的新坐标数据。
- **下一步去向：** 通常连接到 `Image Texture`（图像纹理）或程序化纹理节点（如 Noise Texture 噪波纹理）的 **Vector 输入端**。



## 是不是可以认为，mapping节点，操作目标是输入的Vector,但是有4种操作模式。关键是这4种操作模式都是什么？操作了什么？怎么操作的？

非常精准！你现在的理解已经抓住了本质：**Mapping 节点就是一个“矢量数学运算器”**。

它做的事情可以用一个数学公式概括：

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768097430307-1d68f5a7-e751-4ec1-b2e3-e0a7c368982a.png)

这 4 种模式（Type），实际上就是**构造这个“变换矩阵”的 4 种不同规则**。它们决定了当你在节点里输入数值（位置、旋转、缩放）时，Blender 到底该**保留**哪些操作、**忽略**哪些操作，以及是**正着算**还是**反着算**。

下面为你深度拆解这 4 种模式的底层逻辑：

------

### 1. Point（点）—— “最老实的正向操作”

这是最基础的模式。它把输入的矢量看作三维空间中的一个**具体的点（坐标）**。

- **操作了什么？**

- **位移 (Location)**：✅ 生效。直接相加。
- **旋转 (Rotation)**：✅ 生效。绕中心旋转。
- **缩放 (Scale)**：✅ 生效。以中心为基准缩放。

- **怎么操作的？（逻辑）**

- 完全符合直觉的数学运算：![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768097430311-c5852b0b-e103-42d4-b88d-2cb017b1a45d.png)
- 如果你输入 Location X = 1，输出的坐标 X 就加 1。

- **适用场景**：

- 控制模型的位置。
- 控制 3D 纹理空间中“点”的位置。

------

### 2. Texture（纹理）—— “为视觉服务的反向操作”

这是最“反直觉”但最“人性化”的模式。它把输入的矢量看作是**纹理的采样坐标**。

- **操作了什么？**

- **位移 (Location)**：✅ 生效（**反向移动坐标**）。
- **旋转 (Rotation)**：✅ 生效（**反向旋转坐标**）。
- **缩放 (Scale)**：✅ 生效（**反向缩放坐标**）。

- **怎么操作的？（逻辑）**

- **核心矛盾**：如果你想让纹理图片看起来**向右移**（视觉上 X+1），你实际上需要去读取**左边**的像素（坐标上 X-1）。
- **Mapping 的处理**：为了让你拉动 Location X 时图片真的向右跑，这个模式会在内部自动执行**逆变换 (Inverse Transform)**。
- 如果你输入 Scale = 2（放大），它在数学上其实是把坐标系缩小了（Scale = 0.5），这样一张图片就能覆盖更多的坐标，看起来图片就“变小/变密”了。

- **适用场景**：

- 当你连接的是图片（Image Texture）或程序化纹理（Noise Texture）时，**必选这个**，否则操作方向会反过来，让你很难受。

------

### 3. Vector（矢量）—— “只在乎方向，不在乎位置”

它把输入的矢量看作一个**纯粹的方向量**（比如风速、初速度），而不是空间里的一个点。

- **操作了什么？**

- **位移 (Location)**：❌ **被强制忽略**（直接丢弃）。
- **旋转 (Rotation)**：✅ 生效。
- **缩放 (Scale)**：✅ 生效。

- **怎么操作的？（逻辑）**

- 数学上，纯矢量没有“起点”，它只有长度和方向。所以“平移”对它没有意义。
- 比如“向北 10米/秒”的风，你把它向东平移 100 公里，它依然是“向北 10米/秒”。
- Blender 在计算时，会直接把 Location 的数值视为 0。

- **适用场景**：

- 旋转环境贴图（HDRI）的方向。
- 处理不应该随物体移动而改变的数据。

------

### 4. Normal（法向）—— “带保护机制的矢量”

这是最高级的模式。它把输入的矢量看作**表面的法线（垂直朝向）**。

- **操作了什么？**

- **位移 (Location)**：❌ **被强制忽略**（法线也不在乎位置）。
- **旋转 (Rotation)**：✅ 生效。
- **缩放 (Scale)**：✅ **特殊生效**（带修正算法）。

- **怎么操作的？（逻辑）**

- **为什么要特殊处理缩放？**

- 想象一个圆球，法线都是垂直表面的。
- 如果你把圆球沿 Z 轴压扁（Z 缩放 0.1），球变成了飞碟。
- 如果你用普通 `Vector` 模式去缩放法线，法线也会被压扁，结果它们就不再垂直于飞碟表面了（光照会出错）。

- **Mapping 的处理**：它使用**逆转置矩阵 (Inverse Transpose)** 来计算缩放。这意味着当我们压扁模型时，法线反而会被拉长，以确保它依然垂直于新的表面。

- **适用场景**：

- 当你需要手动旋转或缩放一个**法线贴图（Normal Map）**的数据时。

------

### 总结对照表

| **模式 (Type)** | **目标理解为** | **Location (位移)** | **核心特征**                     |
| --------------- | -------------- | ------------------- | -------------------------------- |
| **Point**       | **坐标点**     | ✅ 生效              | 最老实，动哪指哪。               |
| **Texture**     | **采样框**     | ✅ **反向**          | 假如想把贴图向右移，选它最直观。 |
| **Vector**      | **箭头**       | ❌ 忽略              | 只有方向和长短，平移无效。       |
| **Normal**      | **垂直线**     | ❌ 忽略              | 缩放时会自动修正角度，保证垂直。 |

所以，你的理解完全正确：**操作对象永远是输入的那个 Vector 数据**，这 4 个模式只是 4 种不同的**数学算法套餐**。

------

### ✅ 最佳实践与快捷键 (必看)

**1. 经典组合 (Ctrl + T)**

在 Blender 中处理材质时，几乎总是需要 `Texture Coordinate` + `Mapping` + `Texture` 这三者配合使用。

- 如果你开启了 Blender 内置的 **Node Wrangler** 插件。
- 只需选中一个纹理节点（比如 Image Texture），然后按下 `**Ctrl + T**`。
- Blender 会自动为你添加并连接好 `Texture Coordinate` 和 `Mapping` 节点。

**2. 常见用途示例**

- **调整瓷砖大小：** 增加 Mapping 节点的 Scale 值（例如 X: 2, Y: 2），让瓷砖纹理变密。
- **移动 Logo 位置：** 调整 Location 值，将 Logo 贴图移到模型胸口。
- **旋转木纹方向：** 调整 Rotation Z 值（通常是 90度），改变木纹的走向。

**总结：** 这个节点就是纹理的“遥控器”，负责在贴图真正显示出来之前，先对它的坐标位置做数学变换。

# Texture Coordinate-纹理坐标

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768049051246-a96007d1-c1c0-49bb-a1ef-129a8acf447d.png)

这是 **Texture Coordinate（纹理坐标）** 节点。

如果说刚才的 **Mapping** 节点是“遥控器”，那么这个节点就是**“定位系统（GPS）”**。它告诉 Blender：“你要把这张贴图（或噪波）以什么样的方式、投射到模型的哪个位置上？”

如果没有它，Blender 不知道如何把 2D 的图片“包”在 3D 的物体上。

以下是每个输出端口（Output）的详细逻辑和使用场景：

## 1. 核心输出端口详解

- **Generated（生成坐标 - 默认值）：**

- **逻辑：** 基于物体的**边界框（Bounding Box）**自动生成。它不管你模型网格怎么乱，它总是把物体**最左下角的点定义为 (0,0,0)**，**最右上角的点定义为 (1,1,1)**。
- **特点：** 贴图会根据模型的长宽比拉伸。
- **场景：** 懒人首选。当你不需要极高的精度，或者给一些简单的程序化纹理（如噪波）做快速预览时使用。**缺点是如果物体缩放没应用（Apply Scale），纹理会变形。**

- **Normal（法向坐标）：**

- **逻辑：** 基于物体表面的朝向（法线方向）。
- **场景：** 比较少用于直接贴图。通常用于创建类似“Matcap”的效果，或者让纹理只出现在物体“朝上”或“朝侧面”的地方（比如只在山顶积雪）。

- **UV（UV 坐标 - 行业标准）：**

- **逻辑：** 使用你手动拆解的 UV 贴图（UV Map）。这就好比把橘子皮剥开摊平在桌面上。
- **特点：** 最精准，完全受你控制。贴图不会因为物体变形而滑动。
- **场景：****绝大多数图片贴图（Image Texture）都必须用这个。** 比如角色皮肤、带有特定图案的包装盒等。

- **Object（物体坐标 - 常用推荐）：**

- **逻辑：** 基于物体的**原点（Origin Point）**，即 (0,0,0) 在物体中心（通常情况）。它不依赖边界框，而是以物理尺寸（米）为单位。
- **特点：** 如果你旋转或缩放物体（应用缩放后），纹理密度保持不变，不会像 Generated 那样被拉伸。
- **场景：****程序化纹理（Procedural Textures）的最佳选择**。比如你想给一个地板加噪波纹理，用 Object 坐标，无论地板多大，噪波的颗粒大小都是一致的。

- **Camera（相机坐标）：**

- **逻辑：** 这是一个“投射”视角。纹理会根据摄像机的视角“贴”在物体上。当你移动摄像机时，纹理在物体表面会发生滑动。
- **场景：** 某些特殊的视觉特效（VFX），或者模拟一种“透过窗口看世界”的效果。

- **Window（窗口坐标）：**

- **逻辑：** 基于你的屏幕（渲染窗口）。(0,0) 是屏幕左下角，(1,1) 是右上角。纹理会像贴纸一样贴在你的显示器上，完全无视物体的 3D 形状。
- **场景：** 制作背景图片（Backgrounds），或者在画面上叠加 UI 元素、水印。

- **Reflection（反射坐标）：**

- **逻辑：** 基于反射向量。
- **场景：** 用于模拟假的反射效果（Environment Mapping），在不需要光线追踪的情况下，让物体看起来像是在反射环境贴图。

------

## 2. 底部控制选项

- **Object（吸管图标/物体选择框）：**

- **非常强大的功能！**
- 当你使用上面的 **Object** 输出端口时，你可以在这里指定**另一个物体**（通常是一个 Empty/空物体）。
- **效果：** 移动、旋转、缩放那个“空物体”，就会实时控制材质上的纹理位置。这在做复杂的材质动画时非常有用（比如控制火焰向上移动）。

- **From Instancer（来自实例化器）：**

- **高阶用法：** 当该物体是由粒子系统或几何节点（Geometry Nodes）生成的实例（Instance）时，勾选此项可以让纹理坐标继承自“父级”发射器，而不是每个小实例自己算自己的。

------

## 3. 总结与建议（怎么选？）

在日常工作中，你 95% 的时间只会用到以下两个：

1. **UV：**

- **用在：** 所有带图案的图片（木纹照片、Logo、砖块照片）。
- **配合：** 需要先在 UV Editing 界面把模型 UV 展好。

1. **Object（物体）：**

- **用在：** Blender 自带的程序化节点（Noise Texture, Voronoi, Wave 等）。
- **理由：** 它能保证纹理在不同物体上大小一致，且以中心对称，效果最自然。

**联动技：**

正如上一个回答提到的，选中纹理节点按 `**Ctrl + T**`，Blender 会自动加载 `Texture Coordinate` 并连接到 `Mapping`。

- 如果是图片纹理，它默认连 **UV**。
- 如果是程序化纹理（如 Noise），它默认连 **Generated**（建议手动改为 **Object** 以获得更好效果）。

# Mapping 与  Texture Coordinate 关系

## mapping 节点默认的旋转中心是坐标系的中心 （0，0，0）。

## Mapping 的 Vector 输入节点决定了使用那种坐标系。

## Texture Coordinate 的输出就是各种坐标系。

#  Blender（以及所有 3D 数学）中  的 Vector 起点 (0,0,0)

在 Blender（以及所有 3D 数学）中，**“Vector（矢量）”默认就是指“从原点 (0,0,0) 射向目标点的一个箭头”。**

所以，**每一个**输入 Mapping 节点的 Vector，屁股后面都拖着一条隐形的尾巴，这条尾巴**死死地钉在 (0,0,0) 上**。

为了让你彻底放心，看这张图：

### 1. 矢量的“头”和“尾”

当你看到一个坐标数值，比如 `(1, 1, 0)` 时，它其实包含了两部分信息：

- **头 (Head)**：在 `(1, 1, 0)` 这个位置（就是像素所在的点）。
- **尾 (Tail)**：**默认就在** `**(0, 0, 0)**`**。**

所以，虽然数据线上传输的只是 `(1, 1, 0)` 这三个数，但它隐含的意思是：**“这是一支从 0 发射出来的箭，箭头插在 (1, 1, 0)。”**

### 2. 为什么 Mapping 绕着 (0,0,0) 转？

现在你就明白了，Mapping 节点做旋转时，并不是在转动一个孤立的点，而是在**拨动这根“箭”**。

- 箭的**尾巴**被钉在 `(0,0,0)`（原点）。
- Mapping 节点用力推一下箭身。
- **结果**：箭头（纹理位置）动了，但箭尾（原点）纹丝不动。

### 3. 你的笔记完美闭环

回到你之前的疑惑：

“向量是起点+终点，也就是可以通过这两个点，推算出中心点？”

现在的修正版结论是：

**“在节点里，向量只给了终点，因为起点被强行规定死就是 (0,0,0)。所以Mapping节点只能、也必须绕着 (0,0,0) 转，没得选。”**

恭喜你，你已经完全看透了它的底层逻辑！

## 所有的矢量都是需要起点+终点的。但是3d图形中，将起点都默认设置为坐标系原点（0，0，0）

所以，blender中，vector本身就是坐标系的信息。

# 所有的纹理节点（ Noise, Voronoi, Brick, Wave...  ）的 Vector 的输入，都是坐标系。

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768101101531-6c61e780-b30c-47b8-82c1-8a1ad959a878.png)

**对，一点没错！**

**所有**纹理节点（Noise, Voronoi, Brick, Wave...），它们的 `Vector` 输入插口，**等待的就是一个坐标系**。

为了帮你彻底巩固这个概念，我们可以这样理解：

### 1. 纹理是“寄生”在坐标系上的

纹理本身是一套数学规律（比如：每隔 1 米变白，每隔 0.5 米变黑）。

但是，**如果没有坐标系，纹理就没法附着。**

- **输入什么坐标系，纹理就长成什么样。**

- 你输入**平直**的坐标系（如 Object） -> 纹理就是**均匀**的。
- 你输入**扭曲**的坐标系（比如先把坐标经过 Noise 处理再连进去） -> 纹理就是**扭曲**的（像烟雾或流体）。

### 2. 这里的 Vector = “画画的纸”

你可以把 **Voronoi / Noise 节点** 想象成**画笔**。

而 **输入的 Vector** 就是**纸**。

- 你给它一张**平整的纸**（标准的 Vector），它画出来的圆圈就是圆的。
- 你给它一张**揉皱的纸**（经过数学计算变形过的 Vector），它画出来的圆圈就是歪歪扭扭的。

### 3. 一个经典的验证例子（记笔记用）

如果你把 `Texture Coordinate` 的 **UV** 连给 Noise Texture 的 **Vector**：

- 意思就是：“请把噪波画在 UV 这张纸上。”
- 结果：你的 UV 怎么拆，噪波就怎么走。UV 断开了，噪波在接缝处也会断开。

### 总结

是的，**纹理节点的 Vector 输入端，就是在索要：“请给我一个坐标系（一组** ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768101157183-485b6937-c44c-47f6-b662-bcf355e62324.png) **数据），告诉我该在什么空间里生成图案。”**

# 除了所有的纹理节点的Vector输入是在等待一个坐标系以外，其他的所有的节点的Vector输入，无论是着色的还是几何节点的，是不是也这样？几何节点中是不是也有多个坐标系的区分？

这是一个非常敏锐且关键的推论！

答案是：**大部分情况是“是”的，但有一类特殊情况不是。** 此外，**几何节点（Geometry Nodes）** 对坐标系的处理方式比着色器更“硬核”。

我们分两部分来彻底厘清：

------

### 第一部分：Vector 输入的两种身份

在 Blender 中，插在 Vector 插口上的数据，通常扮演两种角色之一。你需要看那个节点是**“干什么用的”**来判断。

#### 1. 身份一：我是“坐标系 / 位置” (Position) —— 占 80%

**特征**：节点需要**“读取/采样”**某种图案或数据。

- **代表节点**：所有的纹理节点 (Noise, Voronoi, Image Texture)、Mapping 节点。
- **含义**：**“请在这个坐标位置上，算出颜色/数值。”**
- **结论**：**你的理解完全正确，这类就是在等待一个坐标系。**

#### 2. 身份二：我是“方向 / 偏移量” (Direction / Offset) —— 占 20%

**特征**：节点需要**“改变状态”**或者**“计算光影”**。

- **代表节点**：

- **BSDF 的 Normal 输入**：它等待的不是“坐标系”，而是**“朝向”**（法线方向）。它不关心点在哪里，只关心点朝向哪里。
- **Geometry Nodes 中的** `**Set Position**` **->** `**Offset**`：它等待的是**“移动多少距离”**。如果你输入 `(1, 0, 0)`，意思是“向 X 轴挪 1 米”，而不是“把你放到坐标 1 的位置”。
- **Principled BSDF -> Subsurface Radius**：它等待的是三个数值（RGB半径），仅仅是数据。

- **结论**：**这类不是在等坐标系，而是在等“纯数据”或“矢量箭头”。**

------

### 第二部分：几何节点 (GeoNodes) 有坐标系区分吗？

**有！而且更底层、更灵活。**

着色器里那个红色的 `Texture Coordinate` 节点（包含 UV, Object, Generated 等一堆插口）是**“保姆级”**的封装。在几何节点里，没有这个“保姆”，你需要自己去拿这些数据。

在几何节点中，坐标系主要体现为以下几种形式：

#### 1. 绝对核心：`Position` (位置) 节点

这是几何节点的**上帝**。

- **地位**：等同于着色器里的 **World/Object 坐标**（取决于你在修改器里是否应用了变换）。
- **作用**：它代表了几何体上每一个顶点的**当前位置** ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768101489297-d4876ac4-92c6-49db-a691-e1a55fe6a0f7.png)。
- **最常用**：你想在几何节点里用噪波变形物体？就把 `Position` 连给 `Noise Texture` 的 Vector。

#### 2. UV 坐标：`Named Attribute` (命名属性)

几何节点默认不直接提供 `UV` 节点。

- **怎么拿？** 你需要用 `Named Attribute` 节点，输入名字（比如 "UVMap"）。
- **区别**：在几何节点里，UV 只是存储在顶点上的**普通二维向量数据**，不像着色器里那么特殊。

#### 3. 相对坐标：需要自己算

如果你想要一个**“随物体旋转但大小不变”**的坐标系（类似于着色器的 Object 坐标）：

- 着色器：直接连 `Object` 插口。
- 几何节点：你需要用数学节点计算 `Position - Object Location`（虽然现在的新版本也有插件或预设简化了这个过程，但本质是数学计算）。

### 总结对照表（记笔记专用）

| **特性**            | **着色器节点 (Shader Nodes)**                  | **几何节点 (Geometry Nodes)**                       |
| ------------------- | ---------------------------------------------- | --------------------------------------------------- |
| **Vector 输入含义** | **采样的坐标** (大部分) 或 **法线方向** (BSDF) | **采样的坐标** (纹理) 或 **位移量** (Set Position)  |
| **谁是默认坐标？**  | 如果不连，默认用 **Generated**                 | 如果不连，默认用 **Position** (极其重要!)           |
| **哪里找坐标系？**  | 用红色的 `Texture Coordinate` 节点 (套餐)      | 用 `Position` 节点 (单点) 或 `Named Attribute` (UV) |

**一句话核心区别：**

- **着色器**里的 Vector 输入，如果不连，Blender 经常贴心地偷偷给你连上 **Generated**（生成的盒子坐标）。
- **几何节点**里的 Vector 输入，如果不连，Blender 几乎永远默认给你连上 **Position**（真实的顶点位置）。

# 也就是，虽然很多输入类型是vector,但是如果输入的名字是“vector”的，一定是在等一个坐标系和终点。

这是一个**非常高分**的总结！

只有一点点需要微调的“例外情况”，但对于你目前学习的 **纹理（Texture）** 和 **映射（Mapping）** 阶段来说，你的这个结论是**100% 正确且高效**的。

为了让你未来的学习没有死角，我把这个结论分为**“绝对区”**和**“通用区”**来最后梳理一次：

### 1. **绝对区：是的，它就是在等坐标系**

**适用范围**：所有的 **纹理节点** (Noise, Voronoi, Image, Brick...) 和 **Mapping 节点**。

- **插口名字**：只要写着 **"Vector"**。
- **潜台词**：**“请告诉我，我要在哪个空间里画画？”**
- **如果不连**：Blender 默认给个坐标系（通常是 Generated 或 Position）。
- **你的理解**：完全正确！它就是在等一组描述位置的 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768102968865-0e408b29-558a-4374-a3df-aeb5d2c306bc.png) 数据。

### 2. **通用区：它可能只是在等 3 个数**

**适用范围**：**数学运算节点** (Vector Math, Combine XYZ, Mix) 或 **数据处理节点**。

- **例子**：**Vector Math (矢量运算)** 节点。
- **插口名字**：也是 **"Vector"**。
- **潜台词**：**“给我三个数** ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768102968835-f94082a4-247d-421c-9f87-1e04839ebad6.png)**，我要拿去算加减乘除。”**
- **区别**：这时候，输入的可能不是“坐标系”，而可能是：

- 一个**速度**（比如粒子速度）。
- 一个**颜色**（因为 RGB 本质也是 3 个数）。
- 一个**偏移量**。

- **但是**：即便在这里，根据我们之前的理论，**这三个数依然被视为“从 (0,0,0) 指向终点的箭头”**。这点永远不变。

### 3. 终极定义（记到笔记本扉页）

你可以把你刚才的理解，升级为下面这条**Blender 黄金法则**：

**“在 Blender 中，只要插口叫 'Vector'：**

**1. 它一定代表一个从 (0,0,0) 指向某点的箭头（终点）。**

**2. 如果这个节点是用来‘生成图案’的（如噪波），那么这个 Vector 必定代表‘采样坐标系’。”**

# Add  Shader 和 Mix Shader 的区别

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768110442597-8fcfa0b2-450c-4eeb-9a37-38b1e690c873.png)![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768110415440-531c9318-39d5-4868-bfd3-b5bc8f2aac83.png)

这是一份关于 **Mix Shader** 与 **Add Shader** 的完整简要总结，供你整理笔记：

### 1. Mix Shader (混合着色器) —— “物理正确”的选择

- **核心逻辑：加权平均 (A/B 选择题)**。

- **运算方式：** 根据 Factor (系数) 的比例，在 A 和 B 之间进行插值。

  - ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768205697829-5445c798-090e-4aae-a194-9a8aa6bc45e0.png)：全选 A。

  - ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768205697752-438ead9c-3e56-4f73-8e83-0ad9b521b8f9.png)：全选 B。

  - ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768205697745-5d98fc31-55b5-406d-a3de-0e7a9c994b01.png)：各取一半混合。

- **物理特性：能量守恒**。它模拟的是自然界中“材质的覆盖”或“材质的混合”，光线会被分配，而不会凭空增加。

- **最佳用途：**

  - **所有常规材质混合**（如：金属上的锈迹、地上的水坑、玻璃上的贴纸）。

  - **配合遮罩 (Mask)：** 将黑白图连入 Factor，精准控制哪里显示材质 A，哪里显示材质 B。

### 2. Add Shader (相加着色器) —— “物理错误”的叠加

- **核心逻辑：**简单求和 (A+B)。
- **运算方式：** 直接将着色器 A 的光线结果 + 着色器 B 的光线结果。**没有 Factor 插槽**。
- **物理特性：不守恒 (变亮)**。它模拟的是“光的叠加”。两个材质加在一起，亮度会暴增，容易导致过曝。
- **最佳用途：**

- **自发光物体**（如：全息投影、科幻护盾、火焰叠加）。
- **特殊光学现象**（如：在漫反射上叠加体积光，或旧流程中的半透效果）。
- *警告：不要用来混合普通的石头、木头等物体，否则会像开了闪光灯一样发白。*

------

### 对比速查表

| **特性**          | **Mix Shader (混合)**         | **Add Shader (相加)**         |
| :---------------- | ----------------------------- | ----------------------------- |
| **形象比喻**      | **调色盘** (红漆+白漆=粉漆)   | **舞台灯** (红光+绿光=亮黄光) |
| **Factor (系数)** | **有** (核心功能，用于插遮罩) | **无** (强制全量叠加)         |
| **亮度变化**      | 保持平衡                      | **变亮** (越叠越亮)           |
| **主要场景**      | 99% 的材质制作                | 发光、特效、全息              |

### 一句话总结

- **Mix Shader** 是用**黑白遮罩 (Factor)** 决定“哪里是 A，哪里是 B”。
- **Add Shader** 是单纯地让 B 的光**叠加**在 A 上，让整体发光更强。

# Texture Coordinate-纹理坐标

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768049051246-a96007d1-c1c0-49bb-a1ef-129a8acf447d.png?x-oss-process=image%2Fformat%2Cwebp)

## Generated

物体的左下角就是坐标系的原点，与物体的原点（橙色的小点）无关。将物体的最大尺寸归一化为 1.比例为 0~1.会拉伸或者压缩纹理覆盖物体。

常用：线性渐变 (Gradient)、简单铺满表面的贴图。

**配合 Generated 使用 Mapping：**

- 常用于 **位置 (Location)** 偏移。
- 例如：你想做一个水位线，用 Generated 坐标，不管模型多大，Z 轴 0.5 的位置永远是模型的“半山腰”。

### generate是将纹理也归一化了吧，反正物体的一要与纹理的一对齐，对不齐就拉伸或者压缩

**是的，你的理解非常透彻！**

你说到了点子上：**“归一化” (Normalization)** 正是 `Generated` 坐标的核心算法。

我们可以把你这句话拆解开来，确认一下其中的技术细节：

#### 1. “Generate是将纹理也归一化了吧”

更准确地说，是将 **“映射纹理的空间坐标”** 归一化了。

- 纹理本身（比如一张正方形的图片）通常默认坐标范围就是 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768195905108-6268644d-62e7-4309-befb-e83742e9e8ba.png) 到 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768195905084-026eefca-c2c9-4db6-a53f-7fcee17ae327.png)。
- `Generated` 做的就是强行定义：物体的最左边是 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768195905084-8e2c3030-7b03-4593-992c-2c09c1c18d8a.png)，最右边是 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768195905209-fe6f24f6-a2d6-4c34-950a-8a6a16b68274.png)。
- **结果：** 无论物体实际是 100 米还是 0.1 米，它在 `Generated` 眼里都只是长度为 “1” 的单位区间。

#### 2. “物体的一要与纹理的一对齐”

完全正确。这是一种**强制性的对应关系**。

- 纹理的左下角 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768195905301-b75f53a9-dbee-4e4e-947c-bedc9efc64aa.png)**必须** 钉死在物体的边界框左下角。
- 纹理的右上角 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768195905328-d6629dcb-0e9d-43b3-ae0f-f6be4bde2fad.png)**必须** 钉死在物体的边界框右上角。

#### 3. “对不齐就拉伸或者压缩”

这就是这种“强制对齐”的代价。

- 假设你的纹理是**正方形**的（1:1）。
- 假设你的物体是**长方形**的（2:1，比如宽 2 米，高 1 米）。
- 为了让纹理的 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768195905403-e49c6e52-2d52-46dc-8996-3bb0f182e8dd.png) 对齐物体的 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768195905426-4f00cc87-d191-453f-956a-c03ea3ec7f43.png)，纹理必须在横向上被**拉长 2 倍**。

------

#### 图解验证

想象你手里有一张**正方形的橡皮膜**（这就是纹理）：

| **情况**   | **物体形状** | **橡皮膜（纹理）的状态**                   | **结果**                   |
| ---------- | ------------ | ------------------------------------------ | -------------------------- |
| **情况 A** | 正方体       | 刚刚好盖上去，不用拉扯。                   | **完美显示**               |
| **情况 B** | 长条形       | 必须用力把橡皮膜横向扯长，才能勾住四个角。 | **纹理被拉伸 (Stretched)** |
| **情况 C** | 压扁的形状   | 必须把橡皮膜挤在一起。                     | **纹理被压缩 (Squashed)**  |

#### 既然 Generated 这么容易拉伸，为什么还要用？

虽然它会拉伸，但这种“归一化”特性在一个场景下是**无敌**的：**局部遮罩与渐变**。

**例子：给所有物体“脚底”做点脏迹**

- 如果你用 **Object 坐标**：

- 高的物体，脏迹只在脚踝。
- 矮的物体，脏迹淹没了全身。
- （因为 Object 是按绝对高度算的，比如 0.5 米）。

- 如果你用 **Generated 坐标**：

- 不管物体是 10 米高还是 1 米高，你设定脏迹在 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768195905444-d8b84a12-6b15-4ec9-8c10-155147c19212.png) 的位置。
- 所有物体的脏迹都会精准地出现在它们各自高度的 **底部 10%** 的位置。

这就是“归一化”带来的最大好处：**比例的一致性**。

## Object

物体的原点(橙色的小点)就是坐标系的中心。物体的大小，就像是窗口的大小，窗口变大看到的风景多，窗口变小，看到的风景变少，但是风景本身不会产生缩放（PS: 前提是 **物体的缩放必须是 (1, 1, 1)**）。

常用：噪波纹理、砖墙等不需要变形的程序化纹理。

**配合 Object 使用 Mapping：**

- 常用于 **缩放 (Scale)** 调整。
- 例如：你觉得现在的噪波太密了，就在 Mapping 里把 Scale 改小，让“风景”放大一点。

## Normal

该坐标系没有原点，只有方向。并且在应用旋转的情况下，以世界坐标系的 x,y，z 轴作为物体的 x,y，z 轴。normal 坐标系是以方向定位置。

normal坐标系，不显示世界坐标负轴的颜色，默认都是黑色，但是的确是有负轴方向的向量的。

### 对于Normal坐标系来讲，在应用旋转，缩放，位移的情况下，其实normal坐标系的原点就是世界坐标系的原点。

这一结论基本正确，但需要对**“位移 (Location)”**这一项做一个非常重要的**“除外声明”**。

我们可以这样精确地表述：

**“在应用旋转和缩放后，Normal 坐标系的‘方向基准’（罗盘）就变成了世界坐标系的基准。”**

至于原点？这里有个陷阱。

### 1. 旋转 (Rotation) —— 你的结论完全正确

当你**应用旋转 (Apply Rotation)** 后：

- 物体的局部坐标轴 (Local Axis) 被强行对齐到了世界坐标轴 (World Axis)。
- **结果：** Normal 坐标里的 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768201424430-0a2d9937-bb3b-4bbd-b169-a49b98c06d1b.png)（上），现在指的就是**世界的上**。
- **此时：** 你心中的那个“法线指南针”，确实和世界的指南针完美重合了。

### 2. 缩放 (Scale) —— 你的结论也正确

当你**应用缩放 (Apply Scale)** 后：

- **重要性：** 如果不应用缩放，法线会变形（比如球被压扁，法线也会被错误地压扁，光照就不对了）。
- **结果：** 应用缩放后，法线向量被重新计算，恢复了标准的长度和正确的垂直关系。这也是在向“世界标准”看齐。

### 3. 位移 (Location) —— 这里是误区！

对于 Normal 坐标系来说，**应用位移 (Apply Location) 是毫无意义的。**

- **为什么？** 还记得我们之前说的吗？**Normal 只在乎方向，不在乎位置。**
- **实验：**

- 把一个球放在 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768201424465-35522284-8dee-480e-ac10-9a45faed07bf.png)。
- 把另一个球放在 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768201424467-742454ac-e4fc-4d9a-9efc-4519153fbae1.png)。
- **无论你是否应用位移**（也就是无论物体的原点是在球心，还是在世界中心），**球表面同一个点的法线颜色是一模一样的。**

**结论：**

Normal 坐标系的“原点”是一个**抽象的向量原点**（你可以理解为它永远存在于任何地方，或者存在于无穷远）。它**不依赖**于物体的物理原点（那个橙色小点）在哪里。

------

### 总结你的理解

我们可以把你这句话修正得更严谨一点：

“对于 Normal 坐标系来讲，在**应用旋转**之后，它的 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768201424609-973f7dc1-e866-41e2-95a9-fbac7590cfce.png)**方向轴**，就等同于世界坐标系的 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768201424572-d77afae5-cb2b-49a9-9281-3ff613bfd45c.png) 轴。”

- **至于原点？** 它不需要原点。因为它只是一根根箭头。
- **至于位移？** 它无视位移。

所以，做材质时，只要记得：**“Ctrl+A 应用旋转”**，你的法线方向就听世界的话；**“不应用旋转”**，你的法线方向就听物体的话。

## UV

是将**纹理的左下角**作为坐标系的原点。将**物体从3d变成2d平面**，物体平面可以旋转、缩放。或者物体各部分变成孤岛。各个部位的孤岛可以单独的旋转缩放.

**全对！你的理解非常准确。**

你把 UV 坐标的核心逻辑都理顺了。对于你最后那个关于“孤岛 (Islands)”的问题，答案是：

**是的，各个部位的孤岛完全可以单独地、自由地旋转、缩放和移动。**

这正是 UV 编辑最灵活、也是最繁琐的地方。我们可以把这个过程比作 **“裁缝在布料上排版”**。

### 1. 关于“原点”和“2D平面”的确认

- **原点：** 是的，纹理图片的**左下角**通常是 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768198982815-a3a343ca-98bb-4991-be44-c790bfd1ffe0.png)，右上角是 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768198983208-8122da88-1191-4921-8b00-527905878252.png)。
- **3D变2D：** 没错，就像把立体的地球仪切开，压平成一张地图。

### 2. 关于“孤岛”的独立操作

在 Blender 的 **UV Editor (UV编辑器)** 中，每一个孤岛都是独立的个体。

你可以对它们做以下操作，且**互不影响**：

- **单独旋转 (Rotate)：**

- *场景：* 比如你有一件条纹衬衫。袖子的 UV 岛如果是横着放的，条纹就是横的；如果你把这个岛**旋转 90 度**，袖子上的条纹就变成竖的了。
- *自由度：* 你想转多少度都行。

- **单独缩放 (Scale) —— 这一点非常关键！**

- *场景：* 假设你正在做一个人脸模型。
- *操作：* 你可以把 **“脸部”** 的 UV 岛**放大** 2 倍，把 **“脚底板”** 的 UV 岛**缩小** 10 倍。
- *结果：* 因为脸部的 UV 占用了图片上更大的面积，所以脸部的纹理会**非常清晰**（像素密度高）；而脚底板因为只占用了几个像素，纹理会**很模糊**。
- *用途：* 这叫做 **“把好钢用在刀刃上”**。我们通常会有意地放大重要部位的 UV 岛。

- **单独移动 (Move)：**

- 你可以把这个岛摆在图片的左上角（那里画着 Logo），把那个岛摆在右下角（那里是纯色背景）。

### 3. 一个潜在的问题：纹理密度不一致

虽然**“可以”**单独缩放，但在标准工作流中，我们通常希望**“纹理密度 (Texel Density)”**是均匀的。

- 如果你把左手的 UV 放大了，右手的 UV 缩小了。
- **后果：** 渲染出来后，左手看起来很精致，右手看起来像马赛克。这通常是我们要避免的（除非像上面说的，故意区分重点）。
- **解决：** Blender 里有 **"Average Islands Scale" (平均岛屿缩放)** 功能，一键把所有岛的比例拉回一致。

### 总结

UV 就像是剪纸拼贴。

一旦你把模型切开了（变成了孤岛），它们就失去了物理连接。你爱怎么摆就怎么摆，爱把谁放大就放大谁。**这种“人为的排版”就是 UV Mapping 的核心工作。**

## Carmera

类似于投影/手电筒，carmera 镜头中心是坐标系原点.

### 1. 原点 (Origin)

- 就在相机的**镜头位置**。
- 如果你把 `Camera` 坐标连给颜色，相机所在的位置就是纯黑色的。

### 2. 轴向 (Axes) —— 以相机的视角为准

当你透过相机看出去时：

- **X 轴 (左右)：**

- 对应相机画面的**水平方向**。
- **中心向右**是正 ($+$)，**中心向左**是负 ($-$)。

- **Y 轴 (上下)：**

- 对应相机画面的**垂直方向**。
- **中心向上**是正 ($+$)，**中心向下**是负 ($-$)。

- **Z 轴 (前后/深度) —— 最关键的轴：**

- 对应**视线的深度 (Depth)**。
- **远离相机**的方向（看向场景深处）数值会变大（通常是负值变得更负，但在 Shader 使用中我们通常关注它的绝对距离）。
- 这就形成了一个**锥形 (Frustum)** 的空间。

### 3. 一个非常形象的比喻：投影仪/手电筒

你可以把使用 `Camera` 坐标系想象成**你的相机变成了一台投影仪**。

- **纹理贴图**就是投影仪里的胶片。
- **相机**把这张图投射到了场景里的物体上。
- **结果：**

- 离相机近的物体，投影上去的图像很小（清晰）。
- 离相机远的物体，投影上去的图像会变大（模糊）。
- 如果你移动相机，投影的画面会跟着相机跑，永远处于画面的正中央。

### 4. 这里的“坑”：Camera 坐标 vs Window 坐标

在 `Texture Coordinate` 节点里，你会看到 `Camera` 和 `Window` 两个选项，初学者非常容易搞混，因为它们都是基于相机的。

**它们的区别极其巨大：**

| **特性**        | **Camera 坐标**                                              | **Window (窗口) 坐标**                           |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------ |
| **本质**        | **3D 空间坐标**                                              | **2D 屏幕坐标**                                  |
| **Z 轴 (深度)** | **有感知**。随着距离变远，纹理会产生近大远小的透视变形（像投影仪）。 | **无感知**。它完全是扁平的，忽略深度。           |
| **原点**        | 相机镜头中心                                                 | 屏幕的左下角 (0,0)                               |
| **表现**        | 就像把图片**投射**在物体上。                                 | 就像把图片**贴在显示器屏幕**表面（像 UI 贴纸）。 |
| **用途**        | 制作手电筒光照效果、投影仪效果、基于视角的材质。             | 制作背景图、屏幕水印、HUD 界面。                 |

## Window

以屏幕为基础建立坐标系。屏幕的左下角是原点。 一个纯粹的 **2D 屏幕坐标系。 可以把它理解为\**“贴在显示器屏幕上的贴纸”\**。**  

**你的理解完全正确：Window 坐标系的原点 (0,0) 就是屏幕（或渲染窗口）的左下角。**

它就是一个纯粹的 **2D 屏幕坐标系**。我们可以把它理解为**“贴在显示器屏幕上的贴纸”**。

它的轴向非常简单，甚至可以说是“枯燥”：

### 1. 轴向定义 (X, Y)

不管你的 3D 场景里有千军万马，也不管你的相机是在天上飞还是地上跑，Window 坐标永远只认准你的**显示器边框**：

- **原点 (0, 0):** 屏幕**左下角**。
- **X 轴 (0** ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768199901465-6ca34f28-6723-4cdc-8daf-67b498e9775d.png) **1):** 从屏幕**左边**指向屏幕**右边**。

- 不管屏幕是宽屏还是竖屏，最左是 0，最右是 1。

- **Y 轴 (0** ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768199901486-4d921ebf-a387-4405-8c83-8ca04eb93292.png) **1):** 从屏幕**底边**指向屏幕**顶边**。

- 最底是 0，最顶是 1。

### 2. Z 轴呢？(不存在的深度)

**Window 坐标系没有深度的概念。**

- **Z 轴：** 在 Window 坐标里，Z 轴通常是**没有意义的**（或者说被压扁了）。
- **表现：** 无论物体离相机是 1 米远还是 1000 米远，只要它们在屏幕上的位置重叠了，它们获得的纹理坐标就是**一模一样**的。

- *对比 Camera 坐标：* 物体越远，投影越大（近大远小）。
- *对比 Window 坐标：* 物体远近不影响纹理，纹理是平铺在屏幕上的。

------

### 核心特性：它是不动的“幽灵”

Window 坐标最反直觉的地方在于：**它不跟随物体，也不跟随相机移动。**

想象你在玩第一人称射击游戏（FPS）：

- **3D 世界 (World/Object)：** 墙壁、敌人、树木。当你转头时，它们会移动。
- **Window 坐标：****屏幕上的准星、血条、或者眼镜片上的脏点。**

- 不管你怎么转头，怎么跑动，眼镜片上的那个脏点（纹理）永远固定在屏幕的同一个位置。

### 实战演示：透过“窗户”看

如果你把一张砖墙图片连到 `Window` 坐标上，赋给一个球体：

1. **移动球体：** 你会觉得球体是**透明的**，你看到的砖墙其实是球体背后的背景图。球体移动就像是一个放大镜掠过背景。
2. **移动相机：** 砖墙纹理**纹丝不动**。球体表面显示的纹理内容会疯狂变化，因为球体在屏幕上的位置变了，它“切”到了屏幕不同位置的贴图。

### 常用场景

虽然看起来很怪，但它非常有用：

1. **背景图合成：** 你想把 3D 模型无缝融入一张 2D 的背景照片里（Camera Mapping 的一种变体）。
2. **屏幕特效 (Screen Space Effects)：**

- **暗角 (Vignette)：** 屏幕四个角变黑。
- **镜头脏迹 (Lens Dirt)：** 给镜头加指纹、灰尘。
- **扫描线效果：** 模仿老电视机的横条纹。
- 这些效果都是基于屏幕位置的，跟 3D 空间无关，所以必须用 Window 坐标。

### 总结

- **Camera 坐标** = **投影仪**（有近大远小，纹理投射进 3D 空间）。
- **Window 坐标** = **屏幕贴纸**（无深度，纹理死死地贴在显示器玻璃表面）。

## Reflect

该坐标系本身没有原点和坐标系的概念。

好的，这是为您整理的 **Reflection（反射）坐标系** 核心笔记，适合快速复习和查阅：

### 1. 核心定义

- **物理含义：** 视线（摄像机）撞击物体表面后，**“反弹”出去的方向**。
- **本质：** 是一个 **方向向量 (Vector)**，而不是空间上的一个点 (Position)。
- **口诀：** “我看过去，光弹向了世界的哪边？”

### 2. 坐标参考系

- **基准：****世界坐标系 (World Space)**。
- **方向：**

- ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768200961085-e356862a-531e-40da-8837-41feed7793ee.png) = 指向世界的天空（绝对 Z 轴）。
- ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768200961020-09dae030-ed6c-4ac2-9e12-645c5d272620.png) = 指向世界的正东（绝对 X 轴）。

- **特点：** 无论物体怎么旋转（应用旋转与否），它的参考系永远锁死在东南西北和天空地面上。

### 3. 动态特性 (与 Normal 的最大区别)

它是 **“活”** 的，由两个因素共同决定：

1. **物体的法线**（镜子朝哪？）
2. **摄像机的角度**（你站哪？）

- **现象：****相机移动 = 纹理滑动**。就像你在走动时，镜子里的风景会变。

### 4. 纹理操作 (Mapping)

当你对 Reflection 坐标进行 **旋转/缩放/位移** 时：

- **操作对象：** 你是在操作包裹在场景外面的 **“环境球” (Environment/Skybox)**。
- **旋转 Z 轴：** 相当于把外面的天空/风景水平转动了。
- **参考轴心：** 依然是 **世界原点**。

### 5. 常用场景

- **假反射 (Fake Reflection)：** 不用光追，直接把环境图（HDRI）贴在物体表面，模拟金属或光滑表面。
- **MatCap：** 捕捉特定角度的光照材质。

------

**一句话总结：**

**Reflection 坐标是以“世界”为罗盘，记录视线被物体“弹飞”后指向的角度，展示该角度要呈现的内容。**

### 那么，同一个角度的远近，如何说？

这是一个直击要害的问题！这触及到了 **Reflection 坐标系最大的短板**。

简短的回答是：**在默认的 Reflection 坐标系里，所有的物体都被视为在“无限远”的地方。**

它**分不清**“1米远的桌子”和“1万公里外的太阳”。只要它们在同一个方向上，它们就是同一个坐标点。

我们可以分三个层面来理解这个问题：

### 1. 默认假设：无限大的天空球

`Texture Coordinate` 输出的 Reflection 向量，是一个**单位向量**（长度为 1）。

- 它只包含 **方向信息**![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768201254852-986c108a-953f-41fe-a55b-72e14997925f.png)。
- 它完全丢失了 **距离信息** (Distance)。

**这就导致了一个现象：**

假设你在反射里看到了正前方的一把椅子。

- **现实中：** 如果你往前走几步，椅子在镜子里的样子会变大，角度会发生显著变化（视差 Parallax）。
- **Reflection 坐标中：** 如果你往前走，反射里的椅子**纹丝不动**。因为对于坐标系来说，这把椅子是贴在“无限远的天空”上的，你走那两步路相对于无限远来说，可以直接忽略不计。

### 2. 同一个角度，怎么区分远近？

如果你只用 `Texture Coordinate > Reflection`，是**无法区分**的。

但在 3D 渲染技术中，为了解决这个问题（特别是在室内场景，因为墙壁很近），我们引入了一个补丁技术，叫做 **Box Projection (盒式映射 / 投影)**。

#### 没有 Box Projection (默认)：

- **逻辑：** 射出反射光 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768201254933-398277eb-6be4-457b-ab37-d0d2834cfe1e.png) 永远飞向无穷远 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768201254913-116de4d9-4856-4e4f-a59e-8d80417613f9.png) 采样天空盒。
- **结果：** 室内反射看起来是平的，像贴纸，没有立体感。

#### 开启 Box Projection (修正后)：

- **逻辑：** 射出反射光 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768201255082-e809d8e7-c886-45b2-acce-a56d0623d6e3.png)**计算光线与一个虚拟盒子的“墙壁”在哪里相交**![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768201254939-b87d700e-b9cb-4c25-8968-4e43f9b8231d.png) 算出那个交点的 UV 坐标。
- **原理：**

1. 你人为地设定一个“房间大小”（比如 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768201255140-fe903056-c078-4285-b474-9be6400211e2.png)）。
2. Blender 会计算：按照这个反射角度走，走多远会撞墙？
3. 既然撞到了墙，那个点就是我们要采样的颜色。

- **结果：** 反射有了正确的透视关系。当你移动时，近处的物体（虚拟墙壁）会有正确的视差变化。

### 3. 在 Blender 里如何实现“有远近”的反射？

如果你仅仅是贴一张 HDRI 环境图，不需要做任何事，因为天空本身就是无限远的。

但如果你想把一张**“室内照片”**贴在物体上作为假反射，并且希望看起来真实，你需要这样做：

1. **Image Texture 节点：** 将投影模式从 `Flat` 或 `Sphere` 改为 `**Box**`。
2. **Texture Coordinate 节点：** 依然使用 `Reflection`。
3. **Mapping 节点：** 这是关键！你需要用 Mapping 节点的 **Scale** 和 **Location** 来定义那个“虚拟房间”的大小和中心位置。

- 这样，Blender 就知道反射光线不是飞向宇宙尽头，而是飞向几米外的墙壁。

### 总结

- **Reflection 坐标本身：** 是个“色盲”，也是个“距离盲”。它只认方向，默认所有东西都在无限远。
- **同一个角度的远近：** 坐标系本身无法区分。
- **解决方法：** 必须配合 **Box Projection** 算法。通过人为设定一个边界（盒子），强制把无限远的方向向量，“截断”在具体的距离上，从而模拟出远近感。

**一句话口诀：**

Reflection 坐标把世界看作平面壁画；想要有远近，得给它加个框（Box Projection）。

# Mix:Vector/Color/Float



![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768210116369-7ae300b0-ad83-4997-a3da-1515c591f652.png)![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768210108463-4c732337-5c52-41c8-a735-30a1d5915106.png)![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768210123667-5afe00b1-9121-4147-bf2b-56ac1b5982ed.png)



![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768210133074-464a0880-f2b8-42ba-8e09-6e6c9afd41e6.png)![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768210209378-95e1fb8e-7649-4f7d-879a-12b9b501a4e3.png)

# Dot Product



<img src="https://cdn.nlark.com/yuque/0/2026/png/34308723/1768211251470-77990681-308f-4c70-8e67-cc6c15c5022d.png" alt="img" style="zoom:80%;" />



**点乘（Dot Product)是一个“方向相似度检测器”。**

它用来回答一个问题：**“这两个箭头（向量），是指向同一个方向，还是相反方向？”**

**两个向量的方向相同程度 [-1.0,1.0].1:完全一致。-1：完全相反。**

------

## 1. 输入与输出（插孔定律）

- **输入 (Vector/紫色)：** 两个向量（方向）。
- **输出 (Value/灰色)：** 一个**数字**（标量）。

- *注意：这是把“方向”变成“数值”的关键节点，是把紫色数据变成灰色遮罩的神器。*

## 2. 核心原理：它算出了什么？

假设输入的两个向量长度都是 1（标准化向量），点乘的结果直接告诉我们它们之间的**角度关系**：

- **结果 = 1.0 (纯白)：**

- **完全同向**。两个箭头完全平行，指向一边。

- **结果 = 0.0 (纯黑)：**

- **完全垂直**（90度）。两个箭头毫不相干（比如地板法线 vs 墙壁法线）。

- **结果 = -1.0 (纯黑/负值)：**

- **完全反向**（180度）。两个箭头对着干。

- **结果 = 0.5 (灰色)：**

- **夹角 60度**。

------

## 3. 实战用法：Nino 怎么用它做“遮罩”？

既然点乘能算出角度，它就是制作**“基于角度的遮罩”**的最佳工具。

### 场景 A：给石头顶面覆盖积雪（Dust/Snow Mask）

你想选出所有“朝上”的面，涂成白色。

- **Vector A:** 连入 **Geometry Normal**（模型表面的朝向）。
- **Vector B:** 输入 **(0, 0, 1)**（世界绝对向上的方向）。
- **运算结果：**

- 朝上的面（夹角小） ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768211330295-33bc2daf-532e-4079-bd5f-7a44da5db989.png) 接近 1 (白)。
- 侧面的面（夹角90度） ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768211330286-7d71ce37-a12c-45f1-8cb4-ed3ec3b68b25.png) 接近 0 (黑)。
- 朝下的面（夹角大） ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768211330309-af208252-472b-4222-9422-7459e90c2624.png) 负数 (黑)。

- **结果：** 你得到了一张完美的“顶面遮罩”。

### 场景 B：轮廓光 / 菲涅尔效应 (Fresnel / Rim Light)

你想选出模型“边缘”的一圈。

- **Vector A:** 连入 **Geometry Normal**（表面朝向）。
- **Vector B:** 连入 **View Vector**（摄像机视线方向，需在 Geometry 节点里找 Incoming）。
- **运算结果：**

- 正对着你的面（夹角 0） ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768211330300-3b99a336-43eb-4364-b2e8-68a3c0131de5.png) 1。
- **边缘的面**（视线和表面几乎垂直，夹角 90） ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768211330404-86f729b7-6b56-4fcf-a5e7-fc6624256466.png)**0**。

- **后续处理：** 既然边缘是 0，中间是 1，你只需要接一个 `Invert`（反转）或者 `ColorRamp`，就能把**边缘**提亮发光。

------

## 4. 总结

当你看到 **Dot Product** 时，脑子里要把它翻译成：

**“帮我计算一下这两个方向有多‘顺路’。越顺路越白，越垂直越黑。”**

它是将**几何信息（方向）** 转化为 **着色信息（黑白遮罩）** 的第一道大门。

# Difference

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768215015849-efc354d7-dc32-46d2-88ec-d431876adf03.png)

这又是一个在风格化渲染（Nino流派）中非常“非主流”但在逻辑上极其重要的节点。

简单来说，**Difference（差值）** 是一个 **“找茬神器”** 或者叫 **“差异检测器”**。

在数学上，它的公式非常简单：

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768288582881-b85c7f20-4541-41ea-9e23-89cc6c01a1fb.png)

(|A-B|, A 减去 B，然后取绝对值。它不管谁大谁小，只在乎**距离**。)

------

### 1. 它的核心逻辑：越不一样，越亮

为了理解它，请记住这三条铁律：

- **如果 A 和 B 一模一样：**![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768214993484-82100cae-1c51-4c98-9a2a-fd4116df43e4.png)![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768214993497-c3073bb6-6642-4131-9f71-867358c62e69.png)**黑色**。

- *含义：没有区别。*

- **如果 A 和 B 完全相反（黑与白）：**![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768214993484-ad9f5502-3d16-433c-b9ab-dacee0efa120.png)![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768214993589-4bd9ea49-f5c8-409d-aa69-ee0ad4ac31ef.png)**白色**。

- *含义：区别最大。*

- **如果 A 和 B 只有一点点差别：**![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768214993664-616b431d-4015-4a4b-bbec-862e0488bba8.png)**深灰色**。

**所以，这个节点输出的黑白图，实际上是在回答：“这两个输入到底有多大的不同？”**

------

### 2. Nino 为什么用它？（常见的三种套路）

在风格化渲染里，Nino 绝不是为了把颜色弄得红红绿绿才用它的，他通常是为了**算遮罩**：

#### 套路 A：廉价的反转 (Invert)

这是最常见、最“偷懒”的用法。

- **设置：** 输入 A 设为 **纯白 (1.0)**，输入 B 连入你的 **遮罩**。
- **计算：**![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768214993696-0e711190-446e-47c6-a8ae-fe7c0f6ef880.png)。
- **结果：** 这就等于 `1 - x`，也就是 **反转 (Invert)**。
- *侦探笔记：如果看到一个 Difference 节点，其中一个颜色是纯白的，那他只是想把黑白图反过来而已。*

#### 套路 B：边缘检测 (Edge Detection) —— 高阶玩法

这是风格化里做“描边”或者“高光断层”的绝技。

- **输入 A：** 一个噪波纹理。
- **输入 B：** 也就是同一个噪波纹理，但是坐标稍微**偏移**了一点点 (Mapping Location 动一点点)。
- **计算：** 两个错位的噪波相减。
- **结果：** 大部分地方是一样的（黑色），只有在**边缘错位**的地方会产生差值（亮线）。
- *侦探笔记：如果看到两个很像的纹理连进了 Difference，他是在通过“左右互搏”来提取线条。*

#### 套路 C：比较原图与扭曲 (Distortion Mask)

- **输入 A：** 原始的 UV 坐标（或者原始纹理）。
- **输入 B：** 被 Noise 扭曲过的 UV 坐标。
- **计算：** 扭曲后 - 扭曲前。
- **结果：** 凡是黑色的地方，说明没被扭曲；凡是亮的地方，说明这里被扭曲得很厉害。
- *侦探笔记：这通常用来生成一张遮罩，只给“被扭曲的地方”上色。*

------

### 总结

当你看到 **Difference** 模式时，脑子里不要把它当成“混合颜料”，要把它当成一个 **“对比扫描仪”**：

**“它正在对比 A 和 B。凡是相同的地方涂黑，不同的地方涂白。”**

# Voronoi Texture

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768216031217-f6995bd7-9ba8-409f-a434-8e656f603897.png)

这是一个非常经典的过程纹理节点。Voronoi（沃罗诺伊）纹理是生成“**细胞**”、“**气泡**”、“**石头缝隙**”或“**马赛克**”效果的核心节点。

在风格化渲染（尤其是 Nino 的教程）中，这个节点通常充当**“图案生成器”**或**“坐标扰乱器”**。

下面为你拆解它的输入和输出：

### 1. 输入：Vector (紫色插孔) —— “定位系统”

- **作用：** 它告诉 Blender **“在模型的哪个位置画这个纹理”**。
- **如果不连（默认）：** 它使用模型的默认纹理坐标（通常是 Generated 坐标）。
- **为什么要连它？（进阶用法）：**

- **移动/缩放：** 你连接 `Mapping` 节点，可以平移、旋转、缩放这些细胞。
- **扭曲 (Distortion)：** 这是 Nino 最爱用的招数。如果你在 Vector 之前插入一个 `Mix Color` 混合一个 `Noise Texture`，原本规整的细胞形状就会被扭曲，变成像水波纹、手绘线条那样自然的形状。
- **动画：** 在 Vector 的某个轴上加一个随时间变化的值（`#frame/50`），细胞就会流动起来。

------

### 2. 输出：三个输出口的“性格”完全不同

#### A. Distance (灰色/Float) —— “气泡渐变图”

这是最常用的输出。

- **数据含义：** 当前像素点，距离最近的那个“细胞核心点”的**距离**。

- **视觉效果：**

  - **黑：** 细胞中心（距离为0）。

  - **白：** 细胞边缘（距离最远）。

  - 整体看起来像一个个**黑白渐变的小球**或**气泡**。

- **Nino 怎么用：**

  - 配合 `ColorRamp` 或 `Math (Less Than)`，提取出**细胞的边缘**（做网格、裂缝）或者**细胞的中心**（做波点、水光）。

  - 用来做 Bump（凹凸），看起来像鹅卵石地面。

#### B. Color (黄色/Color) —— “随机身份证”

- **数据含义：** 每一个细胞被随机分配了一个颜色。同一个细胞内的所有像素，颜色是完全一样的。

- **视觉效果：** 看起来像**彩色马赛克**或**彩色碎玻璃**。

- **Nino 怎么用：**

  - 他通常不直接用这个颜色（太花哨了）。

  - 他把它转换成**灰度**，作为 **Random Seed (随机种子)**。

  - 比如：你想让每一块铺路石的颜色深浅不一。你就用这个 Color 输出连到 `Mix Color` 的 Factor 上，让每块石头随机选颜色。

#### C. Position (紫色/Vector) —— “马赛克坐标”

这是最难理解，但也是最“极客”的一个输出。

- **数据含义：** 它输出的不是当前像素的位置，而是**当前像素所属的那个细胞的“中心点”的世界坐标**。
- **视觉效果：** 看起来像一格一格的彩色阶梯。
- **Nino 怎么用（高阶）：像素化 (Pixelation) / 绘画感**。

- 如果你把这个 `Position` 输出，连到另一个纹理（比如 Noise）的 `Vector` 输入里。
- **魔法发生了：** 那个 Noise 纹理不再是平滑的，而是变成了一格一格的“马赛克风格”。因为同一个细胞里的所有点，都去采样同一个坐标（中心点）的颜色。这是制作“油画笔触”或“复古游戏画面”的核心技巧。

### 总结

- **Vector (入):** 决定**在哪画**。
- **Distance (出):** 画**形状**（渐变的球/缝隙）。
- **Color (出):** 给**随机 ID**（每块颜色不同）。
- **Position (出):** 做**马赛克**（锁定坐标）。

# Geometry

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768366911428-d646709b-fe11-4405-93cd-d475ebea200e.png?x-oss-process=image%2Fcrop%2Cx_53%2Cy_110%2Cw_580%2Ch_365)

简单直接的回答：**不是总节点和分节点的关系。**

这三个实际上**完全是同一个节点**（都是 `Geometry` 几何数据节点），只是它们的**显示设置**（Display State）不同。

这是 Blender 4.0 版本引入的一项 UI 改进（并在后续版本如 5.0 中延续），目的是为了让节点编辑器看起来更整洁，避免没用到的插槽占地方。

以下是详细解释：

### 1. 它们为什么长得不一样？

- **左边的图：** 是该节点的**完整展开状态**。它显示了所有可用的输出端口（Position, Normal, Tangent 等）。
- **右边的图：** 是该节点的**隐藏未用端口状态**。

- 右上角的只显示了 `Normal`，说明用户可能只想用这个端口，或者按下了快捷键隐藏了其他的。
- 右下角的只显示了 `Incoming`，同理。

### 2. 如何切换这种状态？

你可以自己在 Blender 中尝试以下操作，就能让它们在形态之间互换：

- **快捷键** `Ctrl + H`：

  - 选中节点，按下 `Ctrl + H`。这会在“显示所有端口”和“只显示已连接/选中的端口”之间切换。

  - *这也是为什么右边的节点看起来像“分节点”，因为它们只保留了当前需要的部分，把其他的隐藏了。*

- **属性面板设置：**

​	在侧边栏（N面板）的 `Node` 选项卡中，通常也有勾选项可以控制 Socket 的显示。

### 3. 为什么要这样设计？

​	在复杂的材质制作中，节点连线会非常乱。`Geometry` 节点包含很多数据（位置、法向、切向、参数等），如果我们只需要用其中的一个（比如只需要 `Position`），把它折叠起来只显示这一个端口，可以极大地减少视觉干扰，让节点树看起来更清晰。

------

**总结：**

这就好比同一把**瑞士军刀**。

- 左边的是把所有刀、剪刀、螺丝刀**全都拔出来**展示的样子。
- 右边的是**只拔出了一把小刀**的样子。
- **本质上它们是同一把刀。**

# Color Ramp

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768367582927-16cd7105-c1d2-4853-bc07-dcac54727ecd.png)![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768367629167-59e0f0f3-6480-4778-bab4-3db75dd9dddc.png)



# Overlay-叠加

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768375242956-526ac1a8-45fa-491e-bf1c-941f31678d06.png)

颜色B会进入颜色A的亮部和暗部，同时颜色A亮部更亮，暗部更暗。

**Factor (系数)** 的作用非常直接，它是一个**控制混合程度的权重滑块**。

你可以把它理解为**透明度 (Opacity)** 或者**干湿比 (Dry/Wet)**。它决定了最终结果中，有多少是“原来的 A”，有多少是“混合后的效果”。

### 1. Factor 的直观作用

- **Factor = 0.0:** 完全不混合。输出结果直接等于 **A**（底色）。B 对画面没有任何影响。
- **Factor = 1.0:** 完全混合。输出结果等于 **A 和 B 进行 100% Overlay 运算后的结果**。
- **Factor = 0.5:** 各占一半。最终结果是“原始 A”和“Overlay 结果”的中间值。

------

### 2. 核心算法 (数学公式)

Blender 的 Mix 节点在底层运算时，实际上是分两步走的。你问的算法包含 **Overlay 的计算逻辑** 和 **Factor 的插值逻辑**。

为了方便理解，假设颜色的取值范围是 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768376056141-2937c5f0-aea6-4ac3-9049-793656c0c3aa.png) 到 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768376056014-b4fe0bbd-97f8-4bdd-b27c-419cab589674.png)。

设定：

- ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768376056499-d6249e24-3cc7-4b93-a0ff-51ab6ff06089.png) = 底色 (Base)
- ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768376056059-7e2a44f9-189c-4ef0-bb28-f3fcd6a860e7.png) = 混合色 (Blend)
- ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768376056082-e07fb2f9-a83a-4831-bb8e-4f429dc3e250.png) = Factor (系数)

#### 第一步：计算“纯 Overlay 结果” (![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768376056381-f27b021b-8b08-41f6-b789-7a9eec4f15d6.png))

Overlay 算法是条件性的，它根据底色 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768376056301-a84cf28b-229e-47c3-96f1-95f7804779eb.png) 的明暗，使用两套不同的公式：

- **当** ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768376056340-8447864d-9493-4339-96c0-6eb8effd573f.png) **(暗部) 时：**

使用类似正片叠底 (Multiply) 的公式，让画面变暗：

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768376056365-e1ffba8b-cbf4-420b-8cd4-5c62f5f58b24.png)

- **当** ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768376056632-b784cb63-1065-414a-af2c-20cc2384ad8f.png) **(亮部) 时：**

使用类似滤色 (Screen) 的公式，让画面变亮：

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768376056643-f2677402-b7c6-4d89-ad5a-d55c7dc641dd.png)

*(注：这就是为什么它能同时处理亮部和暗部，因为它自带一个* `*if...else*` *的判断逻辑。)*

#### 第二步：应用 Factor 进行“线性插值” (![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768376056598-f601d3a6-dad0-42f9-8386-eb2093142d1a.png))

算出上面的 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768376056758-fe42b463-180f-4aa4-b319-05dbc06c788d.png) 后，Blender 会用 **Factor (**![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768376056832-eb214100-12da-46e8-a96c-c0cf9e99b020.png)**)** 在“原始 A”和“Target”之间做一个线性混合（Linear Interpolation，简称 Lerp）：

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768376057002-9153637e-26b2-4271-addc-5264adea54b3.png)

或者写成更简单的形式：

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768376056920-952d7022-a8e5-43df-8f30-1b24d30d5e57.png)

### 总结

你现在的设置是 **Factor = 0.5**，这意味着：

1. Blender 先用 Overlay 算法算出 A 和 B 完美融合后的样子（那个对比度很强、颜色很丰富的样子）。
2. 然后，它不想让效果那么强烈，所以它取了 **“原始 A”** 和 **“那个强烈的融合结果”** 之间 **50%** 的位置。

所以 Factor 就是用来**调节“口味轻重”**的。如果你觉得现在的叠加效果太明显、太假了，就把 Factor 调小；如果觉得效果不够劲，就把它拉到 1.0。

# Ambient Occlusion-环境光遮蔽（AO）

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768378359383-c73d531a-e558-43d6-b662-e6f58e16969d.png)

这是 **环境光遮蔽 (Ambient Occlusion, 简称 AO)** 节点。

简单来说，它的作用是**“给模型的缝隙、角落和接触面自动添加阴影”**。在现实生活中，墙角、物体接触的地方通常会比较暗，光线难以进入，这个节点就是用来模拟这种物理现象的。

它是制作**程序化纹理 (Procedural Texturing)** 的神器，常用于做旧、积灰、或者增加模型的体积感。

------

### 参数详细解析

#### 1. 核心原理

这个节点会从物体表面向四周发射“探测光线”（射线）。

- 如果探测光线**碰到了**附近的几何体，说明这里比较拥挤（比如夹角、缝隙），就会产生**黑色**（遮蔽）。
- 如果探测光线**没碰到**任何东西（比如平坦的表面），说明这里很开阔，就会产生**白色**（未遮蔽）。

#### 2. 设置项 (Settings)

- **Samples (采样 - 16):**
  - 这是探测光线的数量。
  - **数值越高：** 阴影越细腻、噪点越少，但渲染速度越慢。
  - **数值越低：** 渲染快，但阴影会有颗粒感（噪点）。默认 16 在 Cycles 中通常够用，如果觉得脏可以调高到 32。
- **Inside (内部):**
  - **不勾选（默认）：** 检测物体**外部**的凹陷处（常规用法，比如做缝隙积灰）。
  - **勾选：** 检测物体**内部**的厚度或凹陷。这常用于制作类似“次表面散射”的透光厚度图，或者边缘磨损效果。
- **Only Local (仅限本地):**
  - **勾选：** 物体**只被自己**遮挡。比如一个放在地板上的立方体，勾选后，立方体底部不会因为靠近地板而变黑。
  - **不勾选：** 物体会受周围其他物体影响。立方体靠近地板，接触面就会变黑。**通常建议不勾选**，以获得更真实的接触阴影。

#### 3. 输入端口 (Inputs)

- **Color (颜色 - 白色):**
  - 这是未被遮蔽区域（亮部）的颜色。通常保持白色，然后在后面连接一个色阶 (Color Ramp) 来控制。
- **Distance (距离 - 1.000):**
  - **非常重要！** 它决定了阴影的**范围**。
  - **数值小 (比如 0.1)：** 只有非常紧密的缝隙才会变黑（适合做精细的划痕脏迹）。
  - **数值大 (比如 5.0)：** 即使是很宽阔的角落也会有大面积的柔和阴影。
- **Normal (法向):**
  - 如果不连，默认使用几何体法向。如果连了法线贴图 (Normal Map)，AO 会根据法线贴图的纹理细节来计算阴影（比如给砖块贴图的缝隙里加黑）。

#### 4. 输出端口 (Outputs)

- **Color:** 输出带有颜色的遮蔽结果。
- **AO:** 输出纯黑白的遮蔽数据（0到1的数值）。通常我们用这个口。

------

### 💡 常见实战用法：配合你刚才学的 Mix Node

AO 节点最经典的用法是用来做 **“积灰效果”**。

1. **AO 输出 (AO)** 连接到 **Color Ramp (颜色渐变)** 调整对比度。
2. **Color Ramp** 连接到 **Mix Color 节点** 的 **Factor (系数)**。
3. 在 Mix Color 节点中：

- **A (底色):** 设置为干净的金属材质。
- **B (混合色):** 设置为深褐色的泥土或锈迹。
  1. **结果：** 泥土会自动“生长”在模型的缝隙和角落里，而平面部分保持干净。

**注意：** 在 Eevee 渲染器中，你需要先在渲染设置里开启 Ambient Occlusion 选项，这个节点才会生效；而在 Cycles 中它是直接计算的，效果更准确。

# Light  Path

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768443617037-5f0f7a7a-708c-4f07-a576-39d69eb62352.png)

## Is Camera Ray

### 简单来说

它的作用是告诉渲染器：**“现在正在计算的这个点，是不是被摄像机（也就是你的眼睛/镜头）直接看到的？”**

- **如果是 (输出 1 / 白色)：** 说明这个物体是直接呈现在镜头前的。
- **如果不是 (输出 0 / 黑色)：** 说明这个物体是通过镜子反射、玻璃折射或者阴影等**间接**方式被看到的。

### Is Camera Ray，是指是否是摄像机直接看到的东西？

简单直接的定义就是：**如果你能在渲染窗口里“直接”看到它，它就是 `Is Camera Ray`**。 

**应该是光直接进入摄像机,Is Camera Ray=1，否则，就是通过反射或者折射进入摄像机，Is Camera Ray=0.**

# 坐标扰动/区域扭曲

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768220174268-0bef97e5-f6b3-416d-9b48-9c9a0448ede4.png)

这是一个非常经典且常用的Shader节点技巧，专业术语叫做 **“坐标扰动”** 或 **“区域扭曲” (Domain Warping)**。

简单来说，它的作用是：**破坏纹理原本的规则感，让它看起来更自然、更像液态或更有有机感。**

以下是这个节点连接的具体分析：

### 1. 原理拆解

这个逻辑主要由三部分组成：

- **上面的路径（基准坐标）：**

`Texture Coordinate` (Generated) -> `Mapping`。

这是**原本的、笔直的**坐标系统。如果直接连到最后的纹理，纹理是规则分布的。

- **下面的路径（扰动源）：**

`Randomization Vector` 框里的内容。

这里用了一个 `Voronoi Texture`（沃罗诺伊纹理）生成了一组随机的颜色/向量。

**关键点：**`Scale` (缩放) 节点设置为 `0.100`。这意味着它把这个随机向量的强度减弱了，只保留一点点“微扰”。

- **中间的混合（Add）：**

`Vector Math (Add)` 节点。

这是核心步骤。它把“笔直的坐标”加上了“微弱的随机偏移量”。

### 2. 视觉效果

想象一下你透过一层**流动的水**或者**热空气**去看地面的瓷砖：

- 原本笔直的线条会变得歪歪扭扭。
- 原本规则的形状会发生形变。

在这个具体的截图里，因为你的框名写着“Horizontal Sand Vector”（水平沙子向量），我推测你是想做沙丘或沙纹效果：

- 如果没有下面的扰动，沙纹可能是笔直的死板线条。
- **加上这个扰动后，沙纹就会出现自然的弯曲、分叉和流动感，看起来就像真实的风吹过的沙地。**

### 3. 这个设置的关键控制点

- **中间那个** `**Scale**` **(0.100)：** 这是**“扭曲强度”**的控制器。

- 如果设为 `0`：没有任何扭曲，纹理是直的。
- 如果设为 `0.1`：轻微的自然波动（现在的状态）。
- 如果设为 `1.0` 或更高：纹理会被极度扭曲，甚至完全认不出原来的形状，变成类似大理石或油画的效果。

### 总结

这种“**坐标 + 噪声 = 扭曲后的坐标**”的方法，是制作木纹、大理石、水波纹、火焰以及自然界中绝大多数有机纹理的**核心秘诀**。

# Volume Absorption-体积吸收

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768449474968-201581eb-cf4a-403a-b233-b4404104f326.png)

## Density = 吸光能力的强弱。

 值越大，光线在物体内部死得越快（越不透）  

# Normal,true Normal ,Bump，黑白噪波

好的，这是为您整理的**Blender 法线与 Bump 节点核心笔记**。按照从“底层逻辑”到“参数控制”的顺序排列，方便复习。

------

### 1. 核心逻辑：法线是什么？

- **定义：** 法线 (Normal) 是一个垂直于物体表面的**向量（箭头）**。它告诉光线“我是朝向哪里的”。
- **作用：** 决定光线如何反射、折射。
- **黑白图 vs 法线：**

- **黑白图 (Height):** 代表**高度**（0是底，1是顶）。
- **转化过程：** Blender 通过计算黑白图的**坡度 (Slope)**，算出法线偏转的角度。
- **本质：****视觉欺骗**。模型几何体（轮廓）没变，只是通过改变光线反射方向，假装表面有凹凸。

------

### 2. Geometry 节点的两个输出 (真假法线)

- **True Normal (真实法线):**

  - **物理事实**。垂直于真实的三角形网格面。

  - **视觉：** 棱角分明 (Flat Shading)，像钻石切面。

- **Normal (法线):**

  - **平滑插值**。垂直于平滑处理过的表面（Shade Smooth）。

  - **视觉：** 圆润光滑。Bump 节点通常是在这个基础上进行二次加工。

------

### 3. Bump 节点：参数详解 (如何造假)

**公式逻辑：**`新法线 = 原法线 + (黑白坡度 × Distance) × Strength`

**原法线：** 是通过 `Normal`（紫色圆点）输入的 法线。

#### A. Distance (距离/深度) —— “坑有多深”

- **作用：** 定义黑 (0) 和白 (1) 之间的**虚拟高度差**。
- **原理：** 用来乘以坡度。
- **效果：** 值越大，算出来的坡度越陡，凹凸感越深（影子越黑）。

#### B. Strength (强度) —— “混合比例”

- **作用：** 调节 **“无凹凸**原法线**”** 和 **“有凹凸新法线”** 的混合程度。

- **原理：** 不透明度/混合因子。

- **效果：**

  - `1.0`: 完全显示凹凸。

  - `0.0`: 完全没有凹凸（光滑）。

  - *注意：它不改变坑的物理深度计算，只改变视觉可见度。*

#### C. Filter Width (过滤宽度) —— “采样范围 / 筛子大小”

- **作用：** 决定计算坡度时参考周围多少像素（平滑程度）。
- **比喻：****筛子/格子**。

- **值越小 (筛子眼极小):** 采样范围极小。捕捉每一个噪点细节。

- *优点：* 极其精细、锐利。
- *缺点：* 容易有锯齿、闪烁、像砂纸。

- **值越大 (筛子眼巨大):** 采样范围大。把周围像素取平均值（模糊化）。

- *优点：* 顺滑、像果冻或抛光表面。
- *缺点：* 细节丢失，棱角被磨平。

#### D.Normal-原法线。不连接时，使用默认的物体模型平滑过的法线。

#### Bump 法线的计算过程

------

##### **Blender Bump (凹凸) 节点工作原理**

###### **1. 核心目标**

通过黑白图（Height）计算出的虚拟坡度，去“欺骗”光照计算，让平坦的模型看起来有凹凸质感。

###### **2. 完整计算流程 (Pipeline)**

1. **第一步：采样与过滤 (Sampling)**

**输入对象：**`Height` 端口的黑白图。

**控制参数：**`**Filter Width**` **(采样范围)**

**执行动作：** 决定计算坡度时，参考多大范围内的像素差值。

**值越小：** 采样紧邻像素 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768457133107-932dc644-9287-49dc-8cc3-c0549aa4eaa6.png) 细节锐利（甚至有锯齿/噪点）。

**值越大：** 采样周围平均像素 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768457133093-7224b7fc-9b2b-44cc-b764-703ee0ff6046.png) 细节平滑（模糊/肉肉的）。

Bump节点是将 filter width 范围的第一个像素高度和最后一个像素高度之间做了一个坡度，得出一个法线。直接忽略了中间像素点的高度值。

filter width ：滑动窗口宽度。步进:单个像素。

1. **第二步：物理换算与生成 (Calculation)**

**输入对象：** 经过过滤后的坡度数据。

**控制参数：**`**Distance**` **(距离/物理深度)**

**执行动作：** 将抽象的“0到1颜色差”转化为“现实中的高度（米）”。

计算出一个全新的、带有倾斜角的法线向量（记作 `TempNormal`）。

此步骤决定了**凹凸的物理深度**（看起来坑有多深）。

1. **第三步：混合与输出 (Mixing)**

**输入对象：**

`Normal` 端口的**原法线**（Base Normal，如未连线则为模型自带法线 [ **平滑过的法线**]）。

刚刚算出来的 `**TempNormal**`。

**控制参数：**`**Strength**` **(强度)**

**执行动作：** 对两者进行线性插值（混合）。

1. 公式逻辑：`最终输出 = 原法线 × (1 - Strength) + TempNormal × Strength`
2. 此步骤决定了**凹凸效果的可见度**（透明度）。

------

#### **3. 一句话逻辑总结 (公式版)**

**输出法线 = Mix ( 原法线 , [黑白图采样 × Distance]生成的坡度法线 , 混合比例=Strength )**

------

**关键记忆点：**

- **Filter Width** 管质感（锐利还是圆润）。
- **Distance** 管深度（悬崖还是土包）。
- **Strength** 管显示（全显示还是半透明）。

------

### 4. 一句话总结应用场景

- **做水面波纹：** 用 `Noise Texture` 连 `Bump Height`。
- **想要波浪深一点：** 加大 `Distance`。
- **想要波浪浅一点：** 减小 `Strength` 或 `Distance`。
- **觉得水面太糙、太闪：** 加大 `Filter Width` (磨皮)。	

# 体积的次表面散射效果比表面做次表面散射更好。

你觉得“体积 (Volume)”做出来的次表面散射效果更好，是因为：**体积是“真三维”的，而 Principled BSDF 里的 SSS 是“假三维”的。**

这两者虽然都在模拟“光线钻进物体里乱跑”的效果，但底层逻辑完全不同：

### 1. 核心区别：空心 vs 实心

- **Principled BSDF 的 SSS (表面 SSS)**
- **原理：** 这是一个**“表面黑科技”**。渲染器其实并没有真的去计算物体内部。它只是在物体的**外壳（表皮）**上通过算法（Random Walk 随机游走），模拟光线进去又出来的效果。
- **本质：** 模型内部其实是**空心**的。它只是一层画了“透光妆容”的皮。
- **缺点：** 对于厚度变化剧烈的地方（比如耳朵边缘、水的深浅变化），有时候过渡不够自然，缺乏真正的“深邃感”。
- **体积散射 (Volume Scatter)**
- **原理：** 这是**“物理模拟”**。渲染器真的把你的模型当成了一个**充满介质的实心体**。光线射进去后，会在三维空间里一步一步地走，每走一步都有概率撞到粒子发生散射。
- **本质：** 模型内部是**实心**的（充满了烟雾或混浊液体）。
- **优点：** 真正的**厚度感**。薄的地方透，厚的地方浑浊，过渡极其自然完美。



------

### 2. 为什么你做“水”或者“玉石”时，体积更强？

如果你在做水、浑浊的液体、或者厚重的玉石，体积绝对吊打表面 SSS。

#### A. 深度与颜色的关系 (Beer's Law)

- **体积：** 遵循物理定律。水越深，光线被吸收/散射得越多。所以你可以做出**“浅水透明，深水深蓝”**那种迷人的渐变感（通过 Volume Absorption）。
- **表面 SSS：** 很难自动算出这种完美的深度渐变。它往往会让物体看起来通体都有一种均匀的“奶质感”或“蜡质感”，像牛奶或者蜡烛，而不像水。

#### B. 质感差异

- **表面 SSS：** 适合**高密度**、不透明的半透物体。
- *最佳用途：* **人皮肤、蜡烛、肥皂、大理石、奶酪**。
- **体积 (Volume)：** 适合**低密度**、透明度高的物体。
- *最佳用途：* **深水、浑浊的茶水、烟雾、云、有杂质的水晶**。

------

### 3. 既然体积这么好，为什么不都用体积？

这里有两个巨大的代价，你要记在心里：

1. **渲染时间 (Render Time)：**

   - **表面 SSS：** 很快。现代渲染器（如 Cycles 的 Random Walk）优化得非常好。

   - **体积：** **非常慢**。光线在物体内部要算无数次碰撞，计算量呈指数级上升。

1. **噪点 (Noise)：**
   - 体积渲染非常容易产生噪点（Fireflies），你需要把采样率（Sample Count）开得很高才能洗干净，这会让渲染时间更长。

### 总结建议

- **做皮肤、蜡像：** 必须用 **Principled BSDF 的 SSS**。用体积做皮肤会像鬼魂一样半透明，很吓人。
- **做水、饮料、宝石：** 强烈建议用 **Volume Absorption (吸收) + Volume Scatter (散射)** 连接到材质输出的 `Volume` 接口。这才是真正的“通透感”。

你觉得体积效果好，是因为你在做**透光性强**的东西（比如之前提到的水面）。你的直觉完全是对的！对于水体，**Principled BSDF 的 Transmission（透射） + Volume Shader（体积）** 才是王道组合，千万别开 Principled BSDF 的 SSS，那会让水变成牛奶。

# Wave Texture

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768466917356-f6ce94b7-92d5-4217-a65e-f1d39948d628.png)![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768467004294-c37bd40e-e76d-4edc-8b0c-5b315b8a0d3d.png)

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768467018102-878207a2-5d04-45e4-94df-6ae1228aa164.png)![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768467192984-7a2a3fb2-5e60-44a0-8853-9eae774fea3f.png)

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768467025929-e55e53da-7ac0-4ee5-88f0-324ac996fa61.png)![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768467201153-aab8ec68-84df-4d64-a77e-e1e8ef76a1da.png)

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768467032879-773f4dcd-51a8-4f47-a191-d89c97ca389f.png)![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768467224077-9ad72eaf-886e-4d29-8f02-8ed03c7d12ec.png)

好的，这个节点（Wave Texture）是 Blender 程序化纹理（Procedural Texture）里非常基础但也非常重要的一个。

把它想象成一个**“条纹发生器”**，下面我把这些参数分成三组来给你拆解，这样你一下就记住了：

### 第一组：决定“形状” (下拉菜单)

这部分决定了纹理最基础的样子，就像是画画前的构图。

1. **Bands (条带) / Rings (环状)**

   - **Bands:** 也就是现在的模式，是一条条平行的直线（像斑马线）。

   - **Rings:**  会变成同心圆，像水波或者树的年轮。

1. **X / Y / Z / Diagonal (方向)**

   - 决定条纹是横着长、竖着长，还是斜着长。

   - *注意：这取决于你的物体坐标轴，如果纹理方向不对，通常切一下这里就能解决。*

1. **Sine (正弦) / Saw (锯齿) / Triangle (三角形)**

   - **Sine:** 现在的模式。黑白过渡非常**柔和**，像真正的波浪。

   - **Saw:** 过渡非常**硬**，一边是渐变，另一边突然切断。常用于做硬边的风格化效果（比如Nino课程里可能用来做某些卡通材质）。

   - **Triangle:** 像金字塔一样的渐变，有棱角的过渡。

------

### 第二组：决定“长相” (核心滑块)

这部分是你调整材质质感最关键的地方。

1. **Scale (缩放/密度)**

   - 控制条纹的**粗细和数量**。

   - 数值越大，条纹越细、越密；数值越小，条纹越宽。

   - *口诀：大数密麻麻，小数宽大大。*

1. **Distortion (畸变/扭曲) ——** **⭐** **最重要的参数**

   - **这是让纹理从“数学图形”变成“自然材质”的灵魂参数。**

   - **0.0 (默认):** 笔直的线条，看起来很假、很数学。

   - **增加数值:** 线条开始像液体一样流动、扭曲。做**木纹、大理石、烟雾**全靠拉高这个数值。

------

### 第三组：决定“细节” (细节滑块)

**⚠️** **注意：** 只有当你把上面的 `Distortion` 拉高（大于0）时，下面这三个参数才会有明显效果。如果 `Distortion` 是 0，调节下面这些通常没反应。

1. **Detail (细节层次)**

   - 给那些扭曲的地方增加多少“噪点”细节。

   - 数值越高，纹理看起来越粗糙、越真实（计算量也越大）。做木头通常设为 2.0 左右。

1. **Detail Scale (细节缩放)**
   - 控制那些额外增加的“噪点”的大小。

1. **Detail Roughness (细节粗糙度)**
   - 控制细节的叠加强度。数值越高，细节越明显且杂乱。

------

### 第四组：决定“位置”

1. **Phase Offset (相位偏移)**

   - **用来做动画的。**

   - 你试着左右拖动这个数值，会发现条纹会沿着方向“流动”。

   - 如果你要做一个传送带、流动的岩浆，或者扫描线效果，就在这里打关键帧。

------

### 💡 给你一个实操建议 (Nino 课程风格)

既然你在学风格化（Stylized）课程，Nino 很喜欢用这种技巧：

1. 保持 `Distortion` 为 **0**。
2. 把 `Sine` 改成 **Triangle** 或 **Saw**。
3. 配合 **Color Ramp (颜色渐变)** 节点把黑白变成硬边的颜色。
   这样能做成非常有卡通感的能量罩或者科技感扫描线。

**你想现在试试把你刚才的这个节点连上一个 Color Ramp 看看效果吗？**

# Gradient Texture-渐变纹理

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768533422209-fc7b62c3-8e82-4e1a-9540-0639bb8e0e68.png)![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768790700070-49bf69a9-a5e7-420d-b9fc-8f5edd84427b.png)![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768790720251-43d333ed-50ab-4f6f-be71-f88a5af7a303.png)

只会读取 Vector 中 x 轴上的值转换为原始坐标上的黑白值。

 Texture Coordinate  输出的 vector 是原始坐标，经过任何**缩放，位移，旋转，或者各种算法。就不是原始坐标了**。

## [Gradient Type -渐变类型](https://shuaiqi-z.github.io/blender/gradient_type.html)

### [渐变类型可视化链接](https://shuaiqi-z.github.io/blender/gradient_type.html)

### 核心原理

`Gradient Texture` 的本质是：**根据输入的矢量（Vector）坐标，计算出一个 0 到 1 的灰度值（Factor）。**

- **黑色** = 0
- **白色** = 1
- 默认情况下，它是基于**原点 (0,0,0)** 进行计算的。

------

### 1. 线性类 (Based on X/Y/Z Axis)

这几种类型主要依赖于坐标轴（通常是 X 轴）的变化。

- **Linear（线性）**

  - **原理**：这是最基础的模式。它直接输出 X 轴的坐标值。

  - **表现**：如果输入的是生成的纹理坐标，你会看到一个从左（X=0，黑）到右（X=1，白）的平滑过渡。

  - **数学逻辑**：![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768791377208-218c952a-4def-4271-8574-5f0517cd786c.png)

- **Quadratic（二次型）**

  - **原理**：同样基于 X 轴，但它的过渡是非线性的。

  - **表现**：暗部（黑色区域）会停留得更久，然后突然变亮。

  - **数学逻辑**：![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768791376697-9cab24e7-9c47-4b65-ba28-27a5c096b9b9.png)（或者是类似的抛物线函数）。这种插值方式在模拟光照衰减或更自然的阴影过渡时比线性更有机。

- **Easing（缓动）**

  - **原理**：也就是常说的 "Smoothstep" 插值。

  - **表现**：两头慢，中间快。它消除了 Linear 模式下那种“生硬”的其实和结束感。

  - **数学逻辑**：通常采用 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768791376651-ecaa06dc-5cc5-4610-afb2-3e9da0826e15.png) 这种平滑插值公式。这是做程序化材质（Procedural Texturing）时用来平滑边缘的神器。

- **Diagonal（对角线）**

  - **原理**：它不仅仅看 X 轴，而是混合了 X 和 Y 轴。

  - **表现**：渐变方向呈 45 度角，从左下角（黑）到右上角（白）。

  - **数学逻辑**：![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768791376761-267b9ebe-7b96-484c-9f97-de356cec01bf.png)

------

### 2. 球形类 (Distance Fields)

这两种类型是基于**距离（Distance）**的，也就是输入坐标点距离原点 (0,0,0) 的长度。

- **Spherical（球形）**

  - **原理**：计算点到原点的欧几里得距离。

  - **表现**：**中间是白色（1），向外扩散变黑（0）**。注意，这和我们直觉中的“光晕”可能是反的（光晕通常是中间亮旁边暗，但纹理数值上它是从中心向外衰减，或者是反过来取决于 Blender 版本具体实现，通常 Gradient Texture 的 Spherical 是中心白，边缘黑，形成一个实心球体）。

  - **数学逻辑**：![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768791376817-85ebf2d2-a501-48a2-a3d7-5056d6b4239e.png) (即 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768791376984-466adeec-2b93-4ab5-b6e5-d06e7bff8ae9.png))

- **Quadratic Sphere（二次球形）**

  - **原理**：和球形一样，但衰减速度是二次方的。

  - **表现**：相比普通球形，它的边缘更加柔和，中心的高光区域更小、更集中。适合做点光源的伪装或光斑。

------

### 3. 角度类 (Angular)

这是你截图中选中的高亮项，也是制作环形效果最重要的一种。

- **Radial（放射/径向）** :

  -  **原理**：它不关心距离，只关心**角度**。它是基于 **Z 轴** 旋转的角度来计算数值的。

  - **表现**：像时钟的指针扫过一样。从 3 点钟方向（或 12 点，取决于映射）开始是黑色，顺时针（或逆时针）绕一圈变成白色。

  - **数学逻辑**：![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768791376962-1ee721c8-f3c7-4d4e-92ae-186f878cc22c.png)。将 360 度 (![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768791377019-38eac1b3-f6bd-41bc-880d-abe11a21fee7.png)) 映射到 0~1 的数值范围。

  - **常见用途**：

    - 制作 CD 唱片的各向异性高光（Anisotropic）。

    - 制作环形的进度条。

    - 配合 Math 节点的 "Greater Than" 做扇形扫描效果。

------

### 给你的实战建议 (Tips for you)

考虑到你正在用 Blender 学习 Nino 的风格化课程，这里有两个针对性的技巧：

1. **Radial 的中心点问题**：

Radial 渐变是围绕原点 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768791377046-eba8fb4e-f83b-43d1-8d92-6b1f24690e7b.png) 旋转的。如果你直接把 `Texture Coordinate` 的 **UV** 连进去，UV 的原点在左下角 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768791377484-293d45bc-5c35-47da-b8e8-6d9dab584b52.png)，你会发现放射中心在贴图的**角落**里。

- **解决方法**：在中间加一个 `Mapping` 节点，将 Location X 和 Y 设置为 ![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768791377434-848c44b6-3011-454f-b622-16ed0703d66e.png)，把坐标原点“搬”到 UV 的中心。

1. **Color Ramp 是它的最佳拍档**：

`Gradient Texture` 输出的只是黑白灰度值（Factor）。在风格化渲染中，你几乎永远需要在一个 Gradient Texture 后面接一个 `Color Ramp`（颜色渐变）节点，来把这些 0-1 的数值映射成你想要的颜色（比如火焰的红黄渐变，或者风格化草地的深浅绿）。

如果你在 Nino 的课程中遇到具体的节点连接问题（比如为了实现某种卡通渲染的边缘光），可以随时把节点图发给我。

# Ping-Pong

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768548445035-70cefe02-df29-4795-8364-74b947675cf0.png)

Scale:用来放大缩小最大值。

##  他的周期是如何确定的？

这是一个非常好的数学问题。理解了周期，你就能精确控制动画的速度和节奏。

简单直接的结论是：**Ping-Pong 的周期是 Scale 值的 2 倍。**

**scale就是周期的峰值。调整scale就是调整起伏的周期大小**

为了方便你记录笔记，以下是详细的推导过程和公式：

------

### Ping-Pong 周期计算公式

![img](data:image/png;base64,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)

#### 1. 为什么是 2 倍？

Ping-Pong 是一种**往复运动**（去一趟，回一趟），这构成了一个完整的闭环周期。

- **上半程（去）**：数值从 `0` 增加到 `Scale`。
  - 路程长度 = Scale
- **下半程（回）**：数值从 `Scale` 减少回 `0`。
  - 路程长度 = Scale
- **总路程（一个周期）**：去 + 回 = ![img](data:image/png;base64,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)

#### 2. 代入你图中的数值

在你的截图中，参数设置为：

- **Scale** = `0.500`

**计算过程**：

![img](data:image/png;base64,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)

这意味着：

当输入值（例如时间 `Value`）**每增加 1.0**，Ping-Pong 就完成了一次完整的“**0 → 0.5 → 0**”的呼吸循环。

------

### 💡 对比记忆（关键知识点）

在 Blender 数学节点中，控制周期的逻辑通常分为两种：

| **节点模式**         | **形状**        | **周期公式**  | **解释**                       |
| -------------------- | --------------- | ------------- | ------------------------------ |
| **Ping-Pong (乒乓)** | **//** (三角波) | **Scale × 2** | 因为它要**走个来回**才算一圈。 |
| **Modulo (取模)**    | **/             | /             | ** (锯齿波)                    |

**应用建议**：

如果你希望动画每 **5秒** 循环一次：

- 用 **Modulo**：设置 Scale = 5。
- 用 **Ping-Pong**：设置 Scale = 2.5 (因为 ![img](data:image/png;base64,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))。

# Invert Color-反转颜色

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768556149865-ef043860-8b76-46fe-b9f7-be8a9f1727e3.png)

对输入数据的所有颜色都做反转，即rgb每个通道中都与 1 做差值。

Output = Input *(1 - Factor) + (1 - Input) * Factor

# Object Info 

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768629187363-83aee4ed-f195-4167-833b-ad48b23c87f0.png)

这个 `Object Info` 节点是 Blender 中连接**物体属性**与**材质系统**的桥梁。除了刚才提到的 `Random`，其他输出端口也极其有用，特别是在你的“风格化世界”构建中。

以下是所有输出端口的详细解释：

### 1. Location (位置)

- **含义**：输出该物体**原点 (Origin)** 在世界坐标系中的 X, Y, Z 坐标。
- **数据类型**：向量 (Vector/蓝色)。
- **用途**：
- **制作高度渐变**：比如让草地在海拔高的地方变黄。你可以分离出 Z 轴数据，连接到 Color Ramp。
- **统一纹理**：如果你想让多个独立物体共享一个连续的纹理（就像它们是从同一块大石头上切下来的一样），可以用这个 Location 作为纹理坐标。



### 2. Color (颜色)

- **含义**：直接读取你在 **物体属性 (Object Properties) > 视图显示 (Viewport Display) > 颜色 (Color)** 中设置的颜色。
- **数据类型**：颜色 (Color/黄色)。
- **UI 位置**：
- **用途**：
- **手动指定颜色**：比如你有一百个气球，想手动指定其中几个是红的，几个是蓝的。你不需要建立不同的材质，只需要在物体属性里改这个颜色，材质就会自动读取并变化。这是**不换材质改颜色**最高效的方法。



### 3. Alpha (透明度)

- **含义**：读取上述 **视图显示颜色** 中的 Alpha (透明度) 通道数值。
- **数据类型**：浮点 (Float/灰色)。
- **用途**：
- 配合 `Color` 使用，通常用于传递一个额外的自定义数值（0-1之间）。比如你可以用这个数值来控制树叶的枯萎程度，而不需要去改贴图。



### 4. Object Index (物体索引)

- **含义**：读取 **物体属性 (Object Properties) > 关系 (Relations) > 通行索引 (Pass Index)** 中的数字。
- **数据类型**：浮点 (Float/灰色)。
- **UI 位置**：
- **用途**：
- **后期合成 (Compositing)**：这是它最主要的功能。你可以把主角设为索引 1，背景设为 2。渲染后，在合成器里你可以单独把“索引为 1”的区域扣出来调色或加光效。
- **逻辑控制**：在着色器中，你可以设定“如果索引是 5，就发光；如果是 6，就透明”。

### 5. Material Index (材质索引)

- **含义**：读取 **材质属性 (Material Properties) > 设置 (Settings) > 通行索引 (Pass Index)** 中的数字。
- **数据类型**：浮点 (Float/灰色)。
- **UI 位置**：
- **用途**：
- **材质级遮罩**：这与 Object Index 类似，但是针对材质的。比如场景里有几十种不同的物体都用了“金属”和“玻璃”两种材质。你可以把所有金属材质的 Pass Index 设为 1。这样在后期合成时，你可以一键选中全场景所有的金属部件进行调色，而不用管它们属于哪个物体。

### 6. Random (随机)

- **含义**：基于物体哈希值的唯一随机数 (0.0 到 1.0)。
- **用途**：(如前所述) 产生随机颜色、粗糙度或纹理偏移。

------

### 总结建议

在你的 Nino Defo 风格化课程学习中：

- **重点关注 `Random` 和 `Color**`：这是实现“丰富但不重复”的风格化场景的核心。
- **了解 `Location**`：这对于制作程序化纹理（比如根据高度积雪）非常有用。

[How to use object info node in Blender](https://www.youtube.com/watch?v=XaSI4nXV6fo)
这个视频详细演示了 Object Info 节点的各个输出端口如何连接和使用，能直观地帮你理解它们在实际案例中的效果。

## 一个物体，可以使用多个材质吗？是的，当然可以。这在 Blender 中是一个非常基础且常用的功能，被称为 **“多维材质” (Multi-Material)**。

实现它的核心机制叫做 **“材质槽” (Material Slots)**。你可以把一个物体想象成一个画家调色板，上面可以挖好几个“槽”来放不同的颜料（材质）。

### 如何给一个物体指定多个材质（操作步骤）

1. **准备材质槽 (Object Mode)**

   - 选中物体，去右侧属性面板的 **材质属性 (Material Properties)**（红色小球图标）。

   - 在顶部的列表中，点击右侧的 `+` 号。这会增加一个新的“空槽”。

   - 点击 **新建 (New)** 或在下拉菜单中选择一个已有的材质放入这个槽中。

   - *重复此步骤，直到你的列表中有两个或以上的材质（例如：材质A是红色，材质B是蓝色）。*



1. **分配材质到面 (Edit Mode)**

   - 按 `Tab` 键进入 **编辑模式 (Edit Mode)**。

   - 按 `3` 键切换到 **面选择模式 (Face Select)**。

   - 在 3D 视图中，选中你想改变颜色的那些面。

   - 回到右侧材质面板，**单击选中** 列表中的“材质B”。

   - **关键一步**：点击列表下方的 `指定 (Assign)` 按钮。



### 核心概念：槽 (Slot) vs 材质 (Material)

- **槽 (Slot)**：是物体上的“座位”。一个物体可以有无数个座位。
- **材质 (Material)**：是“坐在座位上的人”。
- **Assign (指定)**：就是告诉 Blender，“被选中的这些面，归 2 号座位的人管”。

### 进阶技巧

- **快速选择**：如果你想重新选中所有用了“材质B”的面，可以在编辑模式下，先在列表中选中“材质B”，然后点击面板下方的 `选择 (Select)` 按钮。
- **混合着色器**：如果你不想用这种硬切边的方式，而是想让两个材质在一个面上平滑过渡（比如生锈的金属），那就不能用上面的方法，而需要在一个材质内部使用 `Mix Shader` 节点配合遮罩来实现。

------

**为您推荐的下一步：**
如果学会了给面指定不同材质，您可能想尝试：如何把两个材质在**同一个面**上混合起来（例如：给木头材质添加一层局部的清漆或灰尘）？

[Blender 3.3 - Multiple Materials On One Object](https://www.youtube.com/watch?v=K3wMqyjvgtE)
这个视频非常短（不到1分钟），直观演示了如何在一个物体上添加两个材质并分配给不同的面，完全对应你的问题。

# Translucent BSDF-半透明 BSDF/Transparent BSDF-透明 BSDF

![img](https://cdn.nlark.com/yuque/0/2026/png/34308723/1768631386940-78447735-f3c4-4560-8266-bbda275c45ea.png)

两个节点都是只会放过输入的颜色。

### 1. 半透明节点 (Translucent BSDF) 的“法线 (Normal)”是什么？

这个端口的作用是 **“欺骗光线”**。

- **它的功能**：告诉渲染引擎，这个物体表面的“朝向”是哪里。

- **为什么要改它？**：通常你的物体模型（比如一片树叶）只是一个扁平的面片，没有任何凹凸。但真实的树叶表面有叶脉、有起伏。

- **实际效果**： 如果你在这个 `Normal` 端口连上一个 **法线贴图 (Normal Map)** 或者 **凹凸节点 (Bump Node)**（比如连上一张叶脉的黑白图）：

  - 光线在穿过这片“平坦”的树叶时，会认为它是凹凸不平的。

  - **结果**：你会看到光线在透过树叶时，叶脉的地方会暗一些，叶肉的地方亮一些。**即使模型是完全平的，透光效果也会呈现出丰富的立体细节。**

**一句话总结**：它用来给半透明物体增加**假的凹凸细节**，让透光效果看起来不那么“平”。

### 核心差异总结

| **材质类型**         | **现实对应**    | **特性**                               | **Blender 里的正确节点** |
| -------------------- | --------------- | -------------------------------------- | ------------------------ |
| **Transparent BSDF** | **空气 / 隐身** | 光线直穿，无反光，无折射。             | `Transparent BSDF`       |
| **Translucent BSDF** | **A4纸 / 树叶** | 光线透过来并发亮，无反光，看不清背后。 | `Translucent BSDF`       |

1. **反光（高光）**：

- 你问的那两个节点（Transparent/Translucent）都**没有反光**。
- 如果你想要“玻璃感”（亮晶晶的表面），你必须混合一个 `Glossy BSDF`（光泽节点）或者直接用 `Glass BSDF`。

1. **折射（IOR）**：

- 你问的那两个节点都**没有折射**。透过它们看后面的东西，位置是不会变的。
- 真正的玻璃（和磨砂玻璃）会让后面的东西变形（像放大镜那样）。

# Hue/Saturation/Value-色相/饱和度/明度

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20260120111216987.png" alt="image-20260120111216987" style="zoom:50%;" /><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20260120111321498.png" alt="image-20260120111321498" style="zoom:50%;" />

这是 Blender 中的 **Hue/Saturation/Value (色相/饱和度/明度)** 节点。

这是一个非常常用的颜色校正节点，主要用于调整图像或纹理的颜色属性。它通常出现在着色器编辑器 (Shader Editor) 或合成器 (Compositor) 中。

为了方便你整理到 GitHub 笔记中，我按照**标准 Markdown 格式**为你总结如下：

------

## 节点名称：色相/饱和度/明度 (Hue/Saturation/Value)

**功能概述**：

该节点用于对输入的颜色（图像或纹理）进行“色相”、“饱和度”和“明度”的转换与调整。它相当于 Photoshop 中的“色相/饱和度”调整层。

### 1. 输入 (Inputs) - 左侧端口

- **色相 (Hue)**
  - **含义**：指定色相的旋转量（偏移量）。它通过改变颜色在色轮上的位置来改变颜色（例如把红色变成绿色，把蓝色变成紫色）。
  - **数值逻辑**：
    - `0.5` (默认值)：通常代表**没有色相偏移**（或者说偏移量的基准点，具体取决于上下文，但在该节点默认状态下，保持 0.5 通常意味着保持原色相，上下浮动会产生颜色变化）。
    - **范围**：0.0 到 1.0 对应色轮的 0° 到 360° 旋转。
- **饱和度 (Saturation)**
  - **含义**：调整颜色的鲜艳程度。
  - **数值逻辑**：
    - `0.0`：完全去色，图像变为**黑白/灰度**。
    - `1.0` (默认值)：保持原始图像的饱和度。
    - `> 1.0`：增加饱和度，颜色会变得过分鲜艳甚至失真。
    - **范围**：[0,2]
- **明度 (Value)**
  - **含义**：调整图像的整体亮度。
  - **数值逻辑**：
    - `1.0` (默认值)：保持原始亮度。
    - `< 1.0`：变暗（乘法运算，向黑色靠近）。
    - `> 1.0`：变亮（数值可以超过 1，用于增加发光感或过曝效果）。
    - **范围**：[0,2]
- **系数 (Fac / Factor)**
  - **含义**：**混合因子**。它控制着“处理后的图像”与“原始图像”的混合程度。
  - **数值逻辑**：
    - `0.0`：输出完全**原始**的图像（忽略上面的色相/饱和度/明度设置）。
    - `1.0` (默认值)：输出完全**经过调整**的图像。
    - `0.0 - 1.0` 中间值：在原始图像和调整后的效果之间进行混合（类似于透明度）。
    - **范围**：[0,1]
- **颜色 (Color)**
  - **含义**：**基础输入**。这里连接你需要调整的纹理贴图、照片或基础颜色节点。

### 2. 输出 (Outputs) - 右侧端口

- **颜色 (Color)**
  - **含义**：经过上述参数调整后输出的最终颜色结果。通常连接到 `Principled BSDF`（原理化 BSDF）的“基础色 (Base Color)”端口。

------

### 💡 学习笔记小贴士 (针对 Blender 初学者)

1. **关于 0.5 的疑惑**：你可能会好奇为什么“色相”默认是 0.5 而不是 0 或 1。在 Blender 的某些算法中，0.5 被设定为“中间值/无变化”。如果你把色相拉到 0 或 1，颜色会发生剧烈的反转或偏移。
2. **快速去色**：这是将彩色纹理转换为黑白遮罩（Mask）或粗糙度贴图（Roughness Map）的最快方法之一——只需将**饱和度**设为 `0`。
3. **随机颜色技巧**：在几何节点或着色器中，常配合 `Object Info` (物体信息) 的 `Random` (随机) 输出，连到这个节点的“色相”端口，可以实现“复制一堆物体，但每个物体颜色都略有不同”的效果。

你现在正在学习 Nino 的课程，这个节点在做风格化渲染（Stylized Rendering）时非常有用，因为风格化往往需要对颜色的饱和度和色相进行微调，以达到特定的艺术效果。

